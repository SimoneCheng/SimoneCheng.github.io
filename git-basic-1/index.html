<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【Git】基本原理、分支與分支合併 · 寫字練習</title><meta name="description" content="【Git】基本原理、分支與分支合併 - Simone Cheng"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/dovefavicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://simonecheng.github.io/atom.xml" title="寫字練習"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="寫字練習" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/dovefavicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/tags/" target="_self">TAGS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about/" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【Git】基本原理、分支與分支合併</h1><div class="post-info">Jan 9, 2023<a class="tag-title" href="/tags/Git/">#Git</a></div><aside class="toc"><div class="toc-title"><div class="text">目錄</div><div class="chevron-down-icon"><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%90%B3-Git-Local-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">🐳 Git Local 基本原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-Git-%E7%9A%84%E8%A8%AD%E5%AE%9A"><span class="toc-text">🦀 Git 的設定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A2%BC%E5%80%89%E5%BA%AB"><span class="toc-text">🦀 初始化代碼倉庫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-git-add-file-%E8%83%8C%E5%BE%8C%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC"><span class="toc-text">🦀 git add [file] 背後發生了什麼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-blob-%E5%B0%8D%E8%B1%A1%E8%88%87-SHA1-%E5%93%88%E5%B8%8C"><span class="toc-text">🦀 blob 對象與 SHA1 哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-Working-Directory-%E5%92%8C-Staging-Area"><span class="toc-text">🦀 Working Directory 和 Staging Area</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-git-commit-%E8%83%8C%E5%BE%8C%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC"><span class="toc-text">🦀 git commit 背後發生了什麼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-Commit-History-Tree"><span class="toc-text">🦀 Commit History Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%90%B3-Branch-%E5%92%8C-HEAD"><span class="toc-text">🐳 Branch 和 HEAD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-%E4%BB%80%E9%BA%BC%E6%98%AF%E5%88%86%E6%94%AF%EF%BC%9F%E4%BB%80%E9%BA%BC%E6%98%AFHEAD%EF%BC%9F"><span class="toc-text">🦀 什麼是分支？什麼是HEAD？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-%E5%88%86%E6%94%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">🦀 分支的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-%E4%BD%BF%E7%94%A8-git-checkout-%E5%87%BA%E7%89%B9%E5%AE%9A%E7%9A%84-commit"><span class="toc-text">🦀 使用 git checkout 出特定的 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-%E9%97%9C%E6%96%BC-git-diff-%E9%80%99%E5%80%8B%E5%91%BD%E4%BB%A4"><span class="toc-text">🦀 關於 git diff 這個命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%90%B3-%E5%88%86%E6%94%AF%E5%90%88%E4%BD%B5%EF%BC%88Branch-Merge%EF%BC%89"><span class="toc-text">🐳 分支合併（Branch Merge）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-Fast-Forward-Merge"><span class="toc-text">🦀 Fast Forward Merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-3-Way-Merge"><span class="toc-text">🦀 3 Way Merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-3-Way-Merge-with-Conflict"><span class="toc-text">🦀 3 Way Merge with Conflict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A6%80-git-rebase-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F"><span class="toc-text">🦀 git rebase 是什麼？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%90%B3-%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="toc-text">🐳 參考資料</span></a></li></ol></div></aside><div class="post-content"><p>因為在工作上大量的用到 git 這個版控工具，所以想好好了解自己每個用到的指令背後實際上發生了什麼事，上了一堂 udemy 的課，寫了一些小筆記。</p>
<span id="more"></span>
<p>筆記來源大部分參考自：<a target="_blank" rel="noopener" href="https://www.udemy.com/course/git-basic/">https://www.udemy.com/course/git-basic/</a> 。</p>
<h2 id="🐳-Git-Local-基本原理解析">🐳 Git Local 基本原理解析</h2>
<h3 id="🦀-Git-的設定">🦀 Git 的設定</h3>
<p>通常在看各式各樣的 git 教學的時候，會看到當使用者下載好 git 之後，教學的下一個步驟是在終端機打入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;[your email]&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;[your name]&quot;</span></span><br></pre></td></tr></table></figure>
<p>這兩行的意思其實會在根目錄建立一個 global 的 git 設定檔（檔名是 .gitconfig），而且這個設定檔會自動帶入到每一個 git repository。除了這個 global 的 git 設定檔之外，每一個 git repository 裡面都有自己的 git 設定檔，可以進到該 repo 透過 <code>git config --list</code> 指令查看。</p>
<p>除了設定使用者之外，git config 其實還可以做非常多其他的設定，來達到 git 的客製化。</p>
<div class="success">
<p>git repository 會優先採用 local config 的設定，再使用 global config 的設定。</p>
</div>
<h3 id="🦀-初始化代碼倉庫">🦀 初始化代碼倉庫</h3>
<p>建立一個 git repository 主要有兩種方法：</p>
<ul>
<li>git clone 遠端的倉庫</li>
<li>建立本地倉庫，再使用 git init</li>
</ul>
<p>透過這兩種方式都可以發現 git repository 裡面出現了一個 <strong>.git</strong> 的資料夾，可以在終端機裡面透過 <code>ls -a</code> 這個指令看到這個資料夾，透過觀察這個資料夾的變化，可以很好地理解 git 是如何運作的。</p>
<p>首先先在這邊放上一個最基本的 .git 資料夾的架構，接下來會透過這個資料夾的變動來一一理解 git 如何運作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure>
<h3 id="🦀-git-add-file-背後發生了什麼">🦀 git add [file] 背後發生了什麼</h3>
<p>當建立一個檔案，並將其透過 <code>git add [檔名]</code> 加入 tracked file 的時候，可以發現 .git 資料夾發生了變化，我們假設目前的變化如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── index // 多了這個</span><br><span class="line">├── objects</span><br><span class="line">|   ├── 54 // 多了這個</span><br><span class="line">│   │   └── 7fe984c2f69bd68e98fca67f99a5c14d1435aa // 多了這個</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure>
<p>可以發現 .git 裡面的 objects 資料夾中多了另外一串奇怪的數字，這一串數字是透過稱為 SHA1 的加密算法算出來的，如果要查看任何有關 objects 資料夾當中的東西的話，可以在終端機當中輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 547fe9 // 只取前六位即可</span><br><span class="line">git cat-file -p 547fe9</span><br><span class="line"></span><br><span class="line">-t: 查看該檔案的類型</span><br><span class="line">-p: 查看該檔案的內容</span><br><span class="line">-s: 查看該檔案的大小</span><br></pre></td></tr></table></figure>
<p>在終端機下了上述這兩個指令之後，可以發現透過 <code>git add [file]</code> 之後，產生的 object 類型是　blob 而裡面的內容則是檔案裡面的文字內容，另外一個很重要的是，我們發現到這個 object 並沒有儲存檔名。（檔名會存在另外一個地方）</p>
<h3 id="🦀-blob-對象與-SHA1-哈希">🦀 blob 對象與 SHA1 哈希</h3>
<ul>
<li>HASH 算法：將任意長度的輸入透過 HASH 算法變換成固定長度的輸出，常常被用來做加密。</li>
<li>常見的 HASH 算法，括號當中的 bit 表示會輸出多少 bit 的字串：
<ul>
<li>MD5 (128 bit) （已被破解）</li>
<li>SHA1 (160 bit) （已被破解）</li>
<li>SHA256 (256 bit)</li>
<li>SHA512 (512 bit)</li>
</ul>
</li>
</ul>
<p><code>git add [file]</code> 之後， git 會根據檔案的類型、大小、修改的內容來產生 HASH 值，然後存到 .git/objects 當中，同時也會壓縮內容。目前 git 算出 HASH 值的方式都是用 SHA1 算法。</p>
<h3 id="🦀-Working-Directory-和-Staging-Area">🦀 Working Directory 和 Staging Area</h3>
<p>git 的工作區大致上可以分成三種不同的類型來理解，分別是 Working Directory、Staging Area、git repository。如下圖所示：</p>
<p><img src="../assets/gitWorkspace.png" alt=""></p>
<p>在檔案尚未被 git 追蹤的時候，會停留在 Working Directory，任何需要被 git 控管的檔案都需要使用 <code>git add [file]</code> 這個指令，來將檔案加入到 Staging Area，最後透過撰寫 commit 存到 git repository 裡面。</p>
<p>在圖中可以看到，Staging Area 下面有一個 index 的字樣，沒錯，有關 Staging Area 的任何訊息都會被儲存在 .git/index 這個資料夾當中。我們可以透過以下指令去檢視目前在 index 的檔案有哪些：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git ls-files // 只顯示檔名</span><br><span class="line">git ls-files -s // 顯示檔名、該檔案的權限、文件內容</span><br></pre></td></tr></table></figure>
<div class="success">
<p>所以可以知道，前面提到的 blob object 只儲存文件內容，而文件的檔名會儲存在 index（索引區）。可以透過 <code>git status</code> 指令來觀察 Staging Area 和 Working Directory 的變化。</p>
</div>
<h3 id="🦀-git-commit-背後發生了什麼">🦀 git commit 背後發生了什麼</h3>
<p>將文件加入到 Staging Area 之後，接著要使用 <code>git commit -m &quot;message&quot;</code> 來生成 commit，生成 commit 的目的是為了將有修改的地方存到代碼倉庫（git repository）當中，那麼 commit 在生成的時候，究竟是生成了什麼呢？</p>
<p>生成一個 commit 之後，git 也會透過 SHA1 算法為每個 commit 算出一組編碼，這時候我們也可以運用上面提到的 <code>git cat-file</code> 指令去觀察 commit 的類型和內容。透過該指令我們可以知道 commit 的類型是 commit，而內容則是 tree 和作者資訊，如下圖範例：</p>
<p><img src="../assets/commitStructure.png" alt=""></p>
<p>tree 當中會儲存前面提到的 blob object，也就是說，tree 裡面存的是目前這個 commit 有修改到的所有檔案。再者，如果這個 commit 是接在另一個 commit 後面的話，除了 tree 之外，則會額外再多看到一個 parent，這個 parent 標示著這個 commit 是接在某個特定的 commit 之後。</p>
<p>除了觀察 commit 本身之外，我們也可以觀察有 commit 的分支，假設輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/refs/heads/master</span><br></pre></td></tr></table></figure>
<p>就可以看到這個 master 的分支最新的 commit 是哪一個。</p>
<p>另外 .git 當中還有一個資料夾稱作 HEAD，可以將 HEAD 想像成一個指針，這個 HEAD 的用途是用來指向目前所在的分支。可以透過以下指令去查看 .git/HEAD 的內容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/HEAD</span><br></pre></td></tr></table></figure>
<h3 id="🦀-Commit-History-Tree">🦀 Commit History Tree</h3>
<p>在前面的幾個部份當中，我們可以發現不管是使用 <code>git add</code> 或 <code>git commit -m</code>  git 都會透過 SHA1 算法來生成一個 git object，而這些 object 都會指向各自關聯到的另外一個 git object，比如說新的 commit 會指向上一個 commit，以此類推，如果有很多個 commit 的話，我們就可以透過這樣的方式去知道整個 commit history。而每一個 commit 會指向該 commit 有修改到的檔案（blob object），透過這個指向，我們也可以知道每一個 commit 修改了什麼。</p>
<p>這樣子不斷指向的過程便會形成一個 commit history tree（如下圖），而我們也可以知道，這樣的結構就是 git 的版本概念。</p>
<p><img src="../assets/commitHistoryTree.png" alt=""></p>
<h2 id="🐳-Branch-和-HEAD">🐳 Branch 和 HEAD</h2>
<h3 id="🦀-什麼是分支？什麼是HEAD？">🦀 什麼是分支？什麼是HEAD？</h3>
<p>在整個 git 版本控制的工作流程當中有一個非常重要的概念，就是分支，在程式開發的流程當中會不斷遇到建立分支、合併分支的過程，在開始講解基本操作之前，先來解釋一下到底什麼是分支？</p>
<p>翻翻 git 的官方文件後，我們可以看到 git 對分支的解釋：</p>
<blockquote>
<p>Branches are named pointers to commits.</p>
</blockquote>
<p>從以上敘述可以知道，分支只是一個指向某個 commit 的指針。此時我們就會知道如果要讓分支這個功能可以運作需要達成兩個條件：</p>
<ol>
<li>要有一個地方可以儲存每個分支指向的哪個 commit 這件事情。 ➡️ 存在 .git/refs/heads/[branch 名稱] 裡面。</li>
<li>要有一個東西可以讓我們知道我們現在在哪一個分支上面。 ➡️ 透過 HEAD 來實現，也就是說只要看 HEAD 指向哪個分支，我們現在就在哪個分支。（HEAD 存在 .git/HEAD）</li>
</ol>
<h3 id="🦀-分支的基本操作">🦀 分支的基本操作</h3>
<ol>
<li><code>git branch</code>：查看目前有哪些分支。如果該分支前面出現 * 字號，表示那是現在所在的分支。</li>
<li><code>git branch [branch 名稱]</code>：創建分支。</li>
<li><code>git checkout [branch 名稱]</code>：切換現在的分支到另外一個分支。</li>
<li><code>git branch -d [branch 名稱]</code>：刪除分支。如果分支沒有 merge 的話，會出現無法刪除分支的提示訊息。</li>
<li><code>git branch -D [branch 名稱]</code>：強制刪除分支。就算分支沒有 merge 也可以刪除。</li>
<li><code>git reflog</code>：會記錄所有在 git 當中的操作，包括被刪除分支的 commit。</li>
<li><code>git branch -m [舊 branch 名稱] [新 branch 名稱]</code>：重新命名分支名稱。</li>
<li><code>git checkout -b [branch 名稱]</code>：創建分支並且切換到該分支。</li>
</ol>
<div class="warning">
<p><strong>注意：</strong><br>
如果現在所在的分支是想要刪除的分支的話，就不能刪除分支。要先移動到別的分支，才能刪除。</p>
</div>
<h3 id="🦀-使用-git-checkout-出特定的-commit">🦀 使用 git checkout 出特定的 commit</h3>
<p><code>git checkout</code> 除了可以用來切換分支之外，也可以用來找出某個特定的 commit。如果不小心刪除了某個分支，可以先用 <code>git reflog</code> 找到被刪除分支的 commit，然後再建立分支，就可以恢復被刪除的分支。如下步驟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. git reflog</span><br><span class="line">2. git checkout [commit sha1值(六個字)]</span><br><span class="line">3. git checkout -b [被刪除的 branch 名稱]</span><br></pre></td></tr></table></figure>
<p>這個用法平常不太常用到，但在特殊情況下特別有用！</p>
<div class="warning">
<p><strong>刪除分支到底刪除了什麼？</strong><br>
刪除分支時，只會刪除分支這個指針，並不會刪除任何的 commit！</p>
</div>
<h3 id="🦀-關於-git-diff-這個命令">🦀 關於 git diff 這個命令</h3>
<p>現在應該也比較少在用 <code>git diff</code> 這個指令了，因為 IDE 可以直接顯示檔案變動的情況，非常方便，但其實也可以透過在終端機打下指令 <code>git diff</code> 來查看 working directory 和 staging area 中文件之間的差別。</p>
<p>如果要查看 staging area 和 git repository 的差別的話，可以用 <code>git diff --cache</code> 來查看。</p>
<h2 id="🐳-分支合併（Branch-Merge）">🐳 分支合併（Branch Merge）</h2>
<p>當團隊裡的人在不同的分支開發完之後，會需要將所有的分支都合併在一起，才是一個完整的應用。此時合併分支時會有幾個不同的狀況。這個單元會一一介紹。</p>
<h3 id="🦀-Fast-Forward-Merge">🦀 Fast Forward Merge</h3>
<p>算是在合併分支的時候遇到的最簡單的一種。</p>
<p>假設目前有兩個分支，分別是 mater 和 bugfix。bugfix 是基於 master 最新的 commit 所創建的另外一個分支，我們在 bugfix 上新增了一個 commit。此時整個 branch 和 commit 的結構大致上如下圖所示：</p>
<p><img src="../assets/fastForwardMerge.png" alt=""></p>
<p>在這樣的結構之下進行 git merge 的話，master branch 的指針會向右移動，會與 bugfix 位於同一個 commit，稱之為 fast forward merge。</p>
<div class="info">
<p>在這裡簡單總結符合 fast forward merge 的條件：分支 B 合併進 分支 A 的時候，分支 B 的第一個 commit 指向分支 A 最新的 commit。</p>
</div>
<h3 id="🦀-3-Way-Merge">🦀 3 Way Merge</h3>
<p>3 Way Merge 是另外一種在合併分支的時候會遇到的狀況，這個狀況應該非常的常見。會發生這樣的狀況是因為：分支 B 合併進 分支 A 的時候，分支 B 的第一個 commit 沒有指向分支 A 最新的 commit。</p>
<p>實際上最常遇到的狀況是，自己從 master 另開新的 feature 分支來開發新的功能的時候，其他同事也會同時開發其他的功能，有可能他們先開發完成 merge 進 master，我自己的 feature 分支就會落後目前的 master 分支。這時候如果我開發完成要準備 merge 進 master，就會發生 3 Way Merge。</p>
<p>如下圖所示（bugfix 分支落後 master 分支一次 commit）：</p>
<p><img src="../assets/3WayMerge-1.png" alt=""></p>
<p>這個情況下，如果進行 merge 而且沒有衝突的話，會自動生成一個新的 commit，這個新的 commit 會同時指向兩個分支的上一個 commit，如下圖：</p>
<p><img src="../assets/3WayMerge-2.png" alt=""></p>
<p>如果用一些 git GUI 工具的話，應該可以看到 branch 的分支圖。當如果一個 repo 很大的時候，有很多 3 way merge 的話，分支圖就會盤根錯節（很醜 👾），這種時候就是 <code>git rebase</code> 出場的時機了（稍後會寫到）！</p>
<h3 id="🦀-3-Way-Merge-with-Conflict">🦀 3 Way Merge with Conflict</h3>
<p>前面提到的 3 Way Merge 如果順順的，沒什麼意外發生的話，就會自動 merge，但如果兩個準備要合併的分支，兩個分支都有修改到同樣的地方的話，就會發生衝突，也就是 conflict。</p>
<p>如果發生衝突的話，可以按照終端機上的說明，一步一步解掉衝突。等到衝突全部解掉後，就可以 merge 了！</p>
<p>有衝突發生的當下可以在終端機打 <code>git status</code> 檢查是哪些檔案發生衝突，再去 vsCode 裡面把衝突解掉就可以了！</p>
<h3 id="🦀-git-rebase-是什麼？">🦀 git rebase 是什麼？</h3>
<p><code>git rebase</code> 可以讓所在的分支，同步另外一個分支的最新 commit，比如說我現在在 feature 1 分支，並且 commit 了三次，此時這個分支落後 master 分支一個 commit。</p>
<p>使用 <code>git rebase master</code> 之後，就可以讓 feature 1 分支的三次 commit 接在 master 分支最新的 commit 之後，如此一來就可以進行 Fast Forward Merge。</p>
<div class="warning">
<p>要特別注意的是使用 <code>git rebase</code> 也有可能會造成衝突，如果有衝突的話需要將衝突解掉才能 rebase。另外使用了 rebase 之後，在該分支上面的 commit 會全部重新計算，因為這幾個 commit 的第一個有了新的 parent commit，所以 commit tree 便重新算了一次，也就是說在該分支所建立的 commit 的 id 會不一樣，雖然每個 commit 的修改內容仍和先前相同。</p>
</div>
<h2 id="🐳-參考資料">🐳 參考資料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.udemy.com/course/git-basic/">Git/GitHub/GitLab 完全教程（包括Git底層原理）</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/writing-a-good-pull-request/">PREV</a><a class="next" href="/JS-weird-parts-3/">NEXT</a></div><div class="copyright"><p>© 2021 - 2024 <a href="https://simonecheng.github.io">Simone Cheng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@10.3.1/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}
</script><script>const tocTitleElement = document.querySelector('.toc-title');
const tocContentElement = document.querySelector('.toc-content');
if (tocTitleElement) {
  tocTitleElement.addEventListener('click', (e) => {
    const isActive = tocContentElement.classList.contains('active') || tocTitleElement.classList.contains('active');
    if (isActive) {
      tocContentElement.classList.remove('active');
      tocTitleElement.classList.remove('active');
    } else {
      tocContentElement.classList.add('active');
      tocTitleElement.classList.add('active');
    }
  });
}</script></body></html>