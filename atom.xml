<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寫字練習</title>
  
  
  <link href="https://simonecheng.github.io/atom.xml" rel="self"/>
  
  <link href="https://simonecheng.github.io/"/>
  <updated>2023-07-15T13:26:14.147Z</updated>
  <id>https://simonecheng.github.io/</id>
  
  <author>
    <name>Simone Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Writing a Good Pull Request</title>
    <link href="https://simonecheng.github.io/writing-a-good-pull-request/"/>
    <id>https://simonecheng.github.io/writing-a-good-pull-request/</id>
    <published>2023-03-10T14:22:05.000Z</published>
    <updated>2023-07-15T13:26:14.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>會想要寫一篇「如何寫好的 pull request」相關的文章，是因為在實作一個大功能的重構時，發了一個龐大的 pull request，把要重構的項目一次修改掉。但這個 pull request 是一個不太好的 pull request：</p><span id="more"></span><blockquote><ol><li>一次 pull request 修改改太多（高達兩千行），reviewer 會看了很痛苦。</li><li>馬上把新的程式碼改掉，舊的程式碼也刪掉之後，沒有辦法確保原本的功能也能照之前的一樣正常運作，因為目前該功能缺少測試。</li></ol></blockquote><p>所以希望透過搜尋相關的資料，讓自己的 pull request 可以寫得好一點。讓 reviewer 可以輕鬆寫意的看懂，功能可以順利上線。</p><h2 id="好的-pull-request-有哪些特質"><a href="#好的-pull-request-有哪些特質" class="headerlink" title="好的 pull request 有哪些特質"></a>好的 pull request 有哪些特質</h2><p>一個好的 pull request 通常具有以下的特質：</p><p><strong>「一，可以得到清楚的回饋或修改建議」</strong></p><p>如果一個 pull request 得到清楚明瞭的回饋或是修改建議，不代表這個 pull request 是不好的，而是表示它讓 reviewer 好閱讀，進而提出具體和清楚的修改建議，</p><p><strong>「二，可以很快速地被 review」</strong></p><p>如果一個 pull request 可以很快速地被 review，那就表示 reviewer 會更願意 review 該 pull request，因為比較不會打斷 reviewr 本來的工作安排。</p><p><strong>「三，reviewer 不會問太多關於這個 pull request 的問題」</strong></p><p>如果你的 pull request 發出去後，reviewer 對這個 pull request 問了很多 How 和 Why 的問題，那可能表示這不是一個好的 pull request，因為 reviewer 可能看不太懂為什麼要發 pull request，或是該 pull request 究竟如何解決了問題。一個好的 pull request 應該要能夠很好地對上述兩個疑問解惑。</p><h2 id="如何寫出好的-pull-request"><a href="#如何寫出好的-pull-request" class="headerlink" title="如何寫出好的 pull request"></a>如何寫出好的 pull request</h2><p>下面來一一列出如何寫出好的 pull request的具體方法。</p><h4 id="遵守團隊訂定的-coding-style-規範"><a href="#遵守團隊訂定的-coding-style-規範" class="headerlink" title="遵守團隊訂定的 coding style 規範"></a>遵守團隊訂定的 coding style 規範</h4><p>這是一定要的，每次發出 pull request 之前，可以先自己檢查寫的 code 有沒有符合團隊的 coding 規範。</p><h4 id="Make-Pull-Request-Small"><a href="#Make-Pull-Request-Small" class="headerlink" title="Make Pull Request Small"></a>Make Pull Request Small</h4><p>一個 pull request 裡面修改的 code 不要太多（個人認為最少最少要控制在 800 行內）。</p><p>因為：</p><ol><li>reviewer 可以更完整地 review pull request</li><li>reviewer 可以更快地 review pull request</li><li>比較容易 merge 進 master</li><li>被退件的時候，不會做太多白工</li></ol><p>具體做法：</p><ol><li>一個 pull request 解決一個問題，將 code 的修改範圍對焦在一個 issue，不要一個 pull request 裡面試圖解決多個 issue。如果一個 issue 要改的 code 還是太多，那表示這個 issue 的 scope 太大了，應該要把 issue 拆得更小。</li><li>把 refactor 拆成一步一步不同的 pull request，不要一次改一堆。</li><li>善用 <code>git add --patch</code> 和 <code>git rebase --interactive</code>。</li><li>如果是在一個要長期進行的 feature branch 的話，可以將該 branch 設為你的 pull request target branch 而不是 master branch。</li></ol><h4 id="Use-Commits"><a href="#Use-Commits" class="headerlink" title="Use Commits"></a>Use Commits</h4><p>commit 寫個好的話，reviewer 也可以更容易看懂該次 commit 做了哪些 code 的修改。可以在 google 搜尋「commit convention」來了解如何好的運用 commit。</p><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><ol><li>手動測試：在發出 pull request 之前，先自己手動測試修改的地方有沒有問題，例如新功能有沒有問題、用 edge case 來測試自己修改的地方有沒有問題。</li><li>自動化測試：如果是新功能的 pull request，且在時程上有時間的話，可以增加自動化測試，確保自己寫出來的 code 是安全的，有了自動化測試，對於未來的重構也會很有幫助。</li><li>視情況在 pull request 的 description 說明測試結果，或是有什麼 edge case 需要 reviewer 注意等等。</li></ol><h4 id="Make-a-Clear-Description"><a href="#Make-a-Clear-Description" class="headerlink" title="Make a Clear Description"></a>Make a Clear Description</h4><p>在 pull request 的 description 中，盡量對以下幾點做清楚的描述，讓 reviewer 更清楚地了解你寫的 pull request 在做什麼：</p><ol><li>描述這個 pull request 解決了什麼問題，同時附上 issue 的連結</li><li>如果有決定採取什麼 design pattern 或是一些迫不得已的 walkaround 的話，也可以在 decription 說明</li><li>測試相關的說明，可以參考上述 Test 提到的第三點。</li></ol><h4 id="Add-possible-risks-and-highlight-risky-code"><a href="#Add-possible-risks-and-highlight-risky-code" class="headerlink" title="Add possible risks and highlight risky code"></a>Add possible risks and highlight risky code</h4><p>如果在發 pull request 之後，有一些不太確定的地方，比如說不確定某段修改的 code 改得好不好，會不會有什麼問題（例如：效能、資安、edge case 等問題）。可以在 pull request 發出之後，特別在該段 code 留個言，請 reviewer 特別注意或是協助你改善 code。</p><h4 id="Rebase-Onto-Fresh-Master-Before-Creating-a-PR"><a href="#Rebase-Onto-Fresh-Master-Before-Creating-a-PR" class="headerlink" title="Rebase Onto Fresh Master Before Creating a PR"></a>Rebase Onto Fresh Master Before Creating a PR</h4><p>在正式 merge 之前，可以先將自己開發的分支 rebase 到 target branch，確保自己的分支一直有在跟 target branch 做同步和更新，這樣可以減少 merge 的衝突，如果 target branch 有什麼新的功能或是 function 也可以在自己的分支使用。</p><h4 id="不要修改已經-review-過的-commit"><a href="#不要修改已經-review-過的-commit" class="headerlink" title="不要修改已經 review 過的 commit"></a>不要修改已經 review 過的 commit</h4><p>如果某些 commits 已經被 review 過的話，就不要再去動它了，不要去修改 commit message 或是 squash 等等。如果有收到 review 需要修改的話，請直接寫一個新的 commit。</p><p>因為如果把舊的改掉的話，reviewer 可能會不知道他已經 review 過舊的部分，又再多看一次，降低了雙方的效率。</p><h4 id="快速地回覆-review"><a href="#快速地回覆-review" class="headerlink" title="快速地回覆 review"></a>快速地回覆 review</h4><p>reviewer 看完你的 pull request 之後，可以快速地針對 reviewer 的回饋進行修改，一來自己寫 code 的邏輯和想法都還記得，二來 reviewer 也還對 review 的記憶比較深刻。不要過了太久才進行修改，不然雙方都很容易忘記。</p><h4 id="發-pull-request-前先跟同事溝通"><a href="#發-pull-request-前先跟同事溝通" class="headerlink" title="發 pull request 前先跟同事溝通"></a>發 pull request 前先跟同事溝通</h4><p>在開始實作之前，可以先將同事討論如何實作，用什麼樣的方法，如何拆分 pull request 等等，也許你的同事可以給你更多不一樣的實作想法。事先討論也可以避免下面的情況：也許你想實作的東西不一定需要修改，可以先和同事確認，避免改了之後，其實不需要改的做白工狀況發生。</p><div class="success">可以參考 google 的 <a href="https://google.github.io/eng-practices/" target="_blank">Google Engineering Practices Documentation</a>，看看 google 是如何訂定 pull request author 和 pull request reviewer guide。</div><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><ul><li><a href="https://google.github.io/eng-practices/">Google Engineering Practices Documentation</a></li><li><a href="https://developers.google.com/blockly/guides/contribute/get-started/write_a_good_pr">Writing a Good Pull Request, Blockly, developers Google</a></li><li><a href="https://betterprogramming.pub/how-to-make-a-perfect-pull-request-3578fb4c112">How to Make a Perfect Pull Request, Anton Chuchkalov, Medium</a></li><li><a href="https://levelup.gitconnected.com/how-to-write-the-perfect-pull-request-d044625ace98">How To Write The PERFECT Pull Request, Software Surplus, Medium</a></li><li><a href="https://google.github.io/styleguide/jsguide.html">Google JavaScript Style Guide</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;會想要寫一篇「如何寫好的 pull request」相關的文章，是因為在實作一個大功能的重構時，發了一個龐大的 pull request，把要重構的項目一次修改掉。但這個 pull request 是一個不太好的 pull request：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【Git】基本原理、分支與分支合併</title>
    <link href="https://simonecheng.github.io/git-basic-1/"/>
    <id>https://simonecheng.github.io/git-basic-1/</id>
    <published>2023-01-09T09:21:05.000Z</published>
    <updated>2023-07-15T13:26:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>因為在工作上大量的用到 git 這個版控工具，所以想好好了解自己每個用到的指令背後實際上發生了什麼事，上了一堂 udemy 的課，寫了一些小筆記。</p><span id="more"></span><p>筆記來源大部分參考自：<a href="https://www.udemy.com/course/git-basic/">https://www.udemy.com/course/git-basic/</a> 。</p><h1 id="Git-Local-基本原理解析"><a href="#Git-Local-基本原理解析" class="headerlink" title="Git Local 基本原理解析"></a>Git Local 基本原理解析</h1><h4 id="Git-的設定"><a href="#Git-的設定" class="headerlink" title="Git 的設定"></a>Git 的設定</h4><p>通常在看各式各樣的 git 教學的時候，會看到當使用者下載好 git 之後，教學的下一個步驟是在終端機打入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;[your email]&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;[your name]&quot;</span></span><br></pre></td></tr></table></figure><p>這兩行的意思其實會在根目錄建立一個 global 的 git 設定檔（檔名是 .gitconfig），而且這個設定檔會自動帶入到每一個 git repository。除了這個 global 的 git 設定檔之外，每一個 git repository 裡面都有自己的 git 設定檔，可以進到該 repo 透過 <code>git config --list</code> 指令查看。</p><p>除了設定使用者之外，git config 其實還可以做非常多其他的設定，來達到 git 的客製化。</p><div class="success">git repository 會優先採用 local config 的設定，再使用 global config 的設定。</div><h4 id="初始化代碼倉庫"><a href="#初始化代碼倉庫" class="headerlink" title="初始化代碼倉庫"></a>初始化代碼倉庫</h4><p>建立一個 git repository 主要有兩種方法：</p><ul><li>git clone 遠端的倉庫</li><li>建立本地倉庫，再使用 git init</li></ul><p>透過這兩種方式都可以發現 git repository 裡面出現了一個 <strong>.git</strong> 的資料夾，可以在終端機裡面透過 <code>ls -a</code> 這個指令看到這個資料夾，透過觀察這個資料夾的變化，可以很好地理解 git 是如何運作的。</p><p>首先先在這邊放上一個最基本的 .git 資料夾的架構，接下來會透過這個資料夾的變動來一一理解 git 如何運作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><h4 id="git-add-file-背後發生了什麼"><a href="#git-add-file-背後發生了什麼" class="headerlink" title="git add [file] 背後發生了什麼"></a>git add [file] 背後發生了什麼</h4><p>當建立一個檔案，並將其透過 <code>git add [檔名]</code> 加入 tracked file 的時候，可以發現 .git 資料夾發生了變化，我們假設目前的變化如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── index // 多了這個</span><br><span class="line">├── objects</span><br><span class="line">|   ├── 54 // 多了這個</span><br><span class="line">│   │   └── 7fe984c2f69bd68e98fca67f99a5c14d1435aa // 多了這個</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><p>可以發現 .git 裡面的 objects 資料夾中多了另外一串奇怪的數字，這一串數字是透過稱為 SHA1 的加密算法算出來的，如果要查看任何有關 objects 資料夾當中的東西的話，可以在終端機當中輸入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 547fe9 // 只取前六位即可</span><br><span class="line">git cat-file -p 547fe9</span><br><span class="line"></span><br><span class="line">-t: 查看該檔案的類型</span><br><span class="line">-p: 查看該檔案的內容</span><br><span class="line">-s: 查看該檔案的大小</span><br></pre></td></tr></table></figure><p>在終端機下了上述這兩個指令之後，可以發現透過 <code>git add [file]</code> 之後，產生的 object 類型是　blob 而裡面的內容則是檔案裡面的文字內容，另外一個很重要的是，我們發現到這個 object 並沒有儲存檔名。（檔名會存在另外一個地方）</p><h4 id="blob-對象與-SHA1-哈希"><a href="#blob-對象與-SHA1-哈希" class="headerlink" title="blob 對象與 SHA1 哈希"></a>blob 對象與 SHA1 哈希</h4><ul><li>HASH 算法：將任意長度的輸入透過 HASH 算法變換成固定長度的輸出，常常被用來做加密。</li><li>常見的 HASH 算法，括號當中的 bit 表示會輸出多少 bit 的字串：<ul><li>MD5 (128 bit) （已被破解）</li><li>SHA1 (160 bit) （已被破解）</li><li>SHA256 (256 bit) </li><li>SHA512 (512 bit)</li></ul></li></ul><p><code>git add [file]</code> 之後， git 會根據檔案的類型、大小、修改的內容來產生 HASH 值，然後存到 .git&#x2F;objects 當中，同時也會壓縮內容。目前 git 算出 HASH 值的方式都是用 SHA1 算法。</p><h4 id="Working-Directory-和-Staging-Area"><a href="#Working-Directory-和-Staging-Area" class="headerlink" title="Working Directory 和 Staging Area"></a>Working Directory 和 Staging Area</h4><p>git 的工作區大致上可以分成三種不同的類型來理解，分別是 Working Directory、Staging Area、git repository。如下圖所示：</p><p><img src="/../assets/gitWorkspace.png"></p><p>在檔案尚未被 git 追蹤的時候，會停留在 Working Directory，任何需要被 git 控管的檔案都需要使用 <code>git add [file]</code> 這個指令，來將檔案加入到 Staging Area，最後透過撰寫 commit 存到 git repository 裡面。</p><p>在圖中可以看到，Staging Area 下面有一個 index 的字樣，沒錯，有關 Staging Area 的任何訊息都會被儲存在 .git&#x2F;index 這個資料夾當中。我們可以透過以下指令去檢視目前在 index 的檔案有哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git ls-files // 只顯示檔名</span><br><span class="line">git ls-files -s // 顯示檔名、該檔案的權限、文件內容</span><br></pre></td></tr></table></figure><div class="success">所以可以知道，前面提到的 blob object 只儲存文件內容，而文件的檔名會儲存在 index（索引區）。可以透過 `git status` 指令來觀察 Staging Area 和 Working Directory 的變化。</div><h4 id="git-commit-背後發生了什麼"><a href="#git-commit-背後發生了什麼" class="headerlink" title="git commit 背後發生了什麼"></a>git commit 背後發生了什麼</h4><p>將文件加入到 Staging Area 之後，接著要使用 <code>git commit -m &quot;message&quot;</code> 來生成 commit，生成 commit 的目的是為了將有修改的地方存到代碼倉庫（git repository）當中，那麼 commit 在生成的時候，究竟是生成了什麼呢？</p><p>生成一個 commit 之後，git 也會透過 SHA1 算法為每個 commit 算出一組編碼，這時候我們也可以運用上面提到的 <code>git cat-file</code> 指令去觀察 commit 的類型和內容。透過該指令我們可以知道 commit 的類型是 commit，而內容則是 tree 和作者資訊，如下圖範例：</p><p><img src="/../assets/commitStructure.png"></p><p>tree 當中會儲存前面提到的 blob object，也就是說，tree 裡面存的是目前這個 commit 有修改到的所有檔案。再者，如果這個 commit 是接在另一個 commit 後面的話，除了 tree 之外，則會額外再多看到一個 parent，這個 parent 標示著這個 commit 是接在某個特定的 commit 之後。</p><p>除了觀察 commit 本身之外，我們也可以觀察有 commit 的分支，假設輸入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/refs/heads/master</span><br></pre></td></tr></table></figure><p>就可以看到這個 master 的分支最新的 commit 是哪一個。</p><p>另外 .git 當中還有一個資料夾稱作 HEAD，可以將 HEAD 想像成一個指針，這個 HEAD 的用途是用來指向目前所在的分支。可以透過以下指令去查看 .git&#x2F;HEAD 的內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/HEAD</span><br></pre></td></tr></table></figure><h4 id="Commit-History-Tree"><a href="#Commit-History-Tree" class="headerlink" title="Commit History Tree"></a>Commit History Tree</h4><p>在前面的幾個部份當中，我們可以發現不管是使用 <code>git add</code> 或 <code>git commit -m</code>  git 都會透過 SHA1 算法來生成一個 git object，而這些 object 都會指向各自關聯到的另外一個 git object，比如說新的 commit 會指向上一個 commit，以此類推，如果有很多個 commit 的話，我們就可以透過這樣的方式去知道整個 commit history。而每一個 commit 會指向該 commit 有修改到的檔案（blob object），透過這個指向，我們也可以知道每一個 commit 修改了什麼。</p><p>這樣子不斷指向的過程便會形成一個 commit history tree（如下圖），而我們也可以知道，這樣的結構就是 git 的版本概念。</p><p><img src="/../assets/commitHistoryTree.png"></p><h1 id="Branch-和-HEAD"><a href="#Branch-和-HEAD" class="headerlink" title="Branch 和 HEAD"></a>Branch 和 HEAD</h1><h4 id="什麼是分支？什麼是HEAD？"><a href="#什麼是分支？什麼是HEAD？" class="headerlink" title="什麼是分支？什麼是HEAD？"></a>什麼是分支？什麼是HEAD？</h4><p>在整個 git 版本控制的工作流程當中有一個非常重要的概念，就是分支，在程式開發的流程當中會不斷遇到建立分支、合併分支的過程，在開始講解基本操作之前，先來解釋一下到底什麼是分支？</p><p>翻翻 git 的官方文件後，我們可以看到 git 對分支的解釋：</p><blockquote><p>Branches are named pointers to commits.</p></blockquote><p>從以上敘述可以知道，分支只是一個指向某個 commit 的指針。此時我們就會知道如果要讓分支這個功能可以運作需要達成兩個條件：</p><ol><li>要有一個地方可以儲存每個分支指向的哪個 commit 這件事情。 ➡️ 存在 .git&#x2F;refs&#x2F;heads&#x2F;[branch 名稱] 裡面。</li><li>要有一個東西可以讓我們知道我們現在在哪一個分支上面。 ➡️ 透過 HEAD 來實現，也就是說只要看 HEAD 指向哪個分支，我們現在就在哪個分支。（HEAD 存在 .git&#x2F;HEAD）</li></ol><h4 id="分支的基本操作"><a href="#分支的基本操作" class="headerlink" title="分支的基本操作"></a>分支的基本操作</h4><ol><li><code>git branch</code>：查看目前有哪些分支。如果該分支前面出現 * 字號，表示那是現在所在的分支。</li><li><code>git branch [branch 名稱]</code>：創建分支。</li><li><code>git checkout [branch 名稱]</code>：切換現在的分支到另外一個分支。</li><li><code>git branch -d [branch 名稱]</code>：刪除分支。如果分支沒有 merge 的話，會出現無法刪除分支的提示訊息。</li><li><code>git branch -D [branch 名稱]</code>：強制刪除分支。就算分支沒有 merge 也可以刪除。</li><li><code>git reflog</code>：會記錄所有在 git 當中的操作，包括被刪除分支的 commit。</li><li><code>git branch -m [舊 branch 名稱] [新 branch 名稱]</code>：重新命名分支名稱。</li><li><code>git checkout -b [branch 名稱]</code>：創建分支並且切換到該分支。</li></ol><div class="warning"><b>注意：</b>如果現在所在的分支是想要刪除的分支的話，就不能刪除分支。要先移動到別的分支，才能刪除。</div><h4 id="使用-git-checkout-出特定的-commit"><a href="#使用-git-checkout-出特定的-commit" class="headerlink" title="使用 git checkout 出特定的 commit"></a>使用 git checkout 出特定的 commit</h4><p><code>git checkout</code> 除了可以用來切換分支之外，也可以用來找出某個特定的 commit。如果不小心刪除了某個分支，可以先用 <code>git reflog</code> 找到被刪除分支的 commit，然後再建立分支，就可以恢復被刪除的分支。如下步驟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. git reflog</span><br><span class="line">2. git checkout [commit sha1值(六個字)]</span><br><span class="line">3. git checkout -b [被刪除的 branch 名稱]</span><br></pre></td></tr></table></figure><p>這個用法平常不太常用到，但在特殊情況下特別有用！</p><div class="warning"><b>刪除分支到底刪除了什麼？</b> 刪除分支時，只會刪除分支這個指針，並不會刪除任何的 commit！</div><h4 id="關於-git-diff-這個命令"><a href="#關於-git-diff-這個命令" class="headerlink" title="關於 git diff 這個命令"></a>關於 git diff 這個命令</h4><p>現在應該也比較少在用 <code>git diff</code> 這個指令了，因為 IDE 可以直接顯示檔案變動的情況，非常方便，但其實也可以透過在終端機打下指令 <code>git diff</code> 來查看 working directory 和 staging area 中文件之間的差別。</p><p>如果要查看 staging area 和 git repository 的差別的話，可以用 <code>git diff --cache</code> 來查看。</p><h1 id="分支合併（Branch-Merge）"><a href="#分支合併（Branch-Merge）" class="headerlink" title="分支合併（Branch Merge）"></a>分支合併（Branch Merge）</h1><p>當團隊裡的人在不同的分支開發完之後，會需要將所有的分支都合併在一起，才是一個完整的應用。此時合併分支時會有幾個不同的狀況。這個單元會一一介紹。</p><h4 id="Fast-Forward-Merge"><a href="#Fast-Forward-Merge" class="headerlink" title="Fast Forward Merge"></a>Fast Forward Merge</h4><p>算是在合併分支的時候遇到的最簡單的一種。</p><p>假設目前有兩個分支，分別是 mater 和 bugfix。bugfix 是基於 master 最新的 commit 所創建的另外一個分支，我們在 bugfix 上新增了一個 commit。此時整個 branch 和 commit 的結構大致上如下圖所示：</p><p><img src="/../assets/fastForwardMerge.png"></p><p>在這樣的結構之下進行 git merge 的話，master branch 的指針會向右移動，會與 bugfix 位於同一個 commit，稱之為 fast forward merge。</p><div class="info">在這裡簡單總結符合 fast forward merge 的條件：分支 B 合併進 分支 A 的時候，分支 B 的第一個 commit 指向分支 A 最新的 commit。</div><h4 id="3-Way-Merge"><a href="#3-Way-Merge" class="headerlink" title="3 Way Merge"></a>3 Way Merge</h4><p>3 Way Merge 是另外一種在合併分支的時候會遇到的狀況，這個狀況應該非常的常見。會發生這樣的狀況是因為：分支 B 合併進 分支 A 的時候，分支 B 的第一個 commit 沒有指向分支 A 最新的 commit。</p><p>實際上最常遇到的狀況是，自己從 master 另開新的 feature 分支來開發新的功能的時候，其他同事也會同時開發其他的功能，有可能他們先開發完成 merge 進 master，我自己的 feature 分支就會落後目前的 master 分支。這時候如果我開發完成要準備 merge 進 master，就會發生 3 Way Merge。</p><p>如下圖所示（bugfix 分支落後 master 分支一次 commit）：</p><p><img src="/../assets/3WayMerge-1.png"></p><p>這個情況下，如果進行 merge 而且沒有衝突的話，會自動生成一個新的 commit，這個新的 commit 會同時指向兩個分支的上一個 commit，如下圖：</p><p><img src="/../assets/3WayMerge-2.png"></p><p>如果用一些 git GUI 工具的話，應該可以看到 branch 的分支圖。當如果一個 repo 很大的時候，有很多 3 way merge 的話，分支圖就會盤根錯節（很醜 👾），這種時候就是 <code>git rebase</code> 出場的時機了（稍後會寫到）！</p><h4 id="3-Way-Merge-with-Conflict"><a href="#3-Way-Merge-with-Conflict" class="headerlink" title="3 Way Merge with Conflict"></a>3 Way Merge with Conflict</h4><p>前面提到的 3 Way Merge 如果順順的，沒什麼意外發生的話，就會自動 merge，但如果兩個準備要合併的分支，兩個分支都有修改到同樣的地方的話，就會發生衝突，也就是 conflict。</p><p>如果發生衝突的話，可以按照終端機上的說明，一步一步解掉衝突。等到衝突全部解掉後，就可以 merge 了！</p><p>有衝突發生的當下可以在終端機打 <code>git status</code> 檢查是哪些檔案發生衝突，再去 vsCode 裡面把衝突解掉就可以了！</p><h4 id="git-rebase-是什麼？"><a href="#git-rebase-是什麼？" class="headerlink" title="git rebase 是什麼？"></a>git rebase 是什麼？</h4><p><code>git rebase</code> 可以讓所在的分支，同步另外一個分支的最新 commit，比如說我現在在 feature 1 分支，並且 commit 了三次，此時這個分支落後 master 分支一個 commit。</p><p>使用 <code>git rebase master</code> 之後，就可以讓 feature 1 分支的三次 commit 接在 master 分支最新的 commit 之後，如此一來就可以進行 Fast Forward Merge。</p><div class="warning">要特別注意的是使用 <code>git rebase</code> 也有可能會造成衝突，如果有衝突的話需要將衝突解掉才能 rebase。另外使用了 rebase 之後，在該分支上面的 commit 會全部重新計算，因為這幾個 commit 的第一個有了新的 parent commit，所以 commit tree 便重新算了一次，也就是說在該分支所建立的 commit 的 id 會不一樣，雖然每個 commit 的修改內容仍和先前相同。</div><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.udemy.com/course/git-basic/">Git&#x2F;GitHub&#x2F;GitLab 完全教程（包括Git底層原理）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因為在工作上大量的用到 git 這個版控工具，所以想好好了解自己每個用到的指令背後實際上發生了什麼事，上了一堂 udemy 的課，寫了一些小筆記。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://simonecheng.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>【克服JS的奇怪部分】Types and Operators</title>
    <link href="https://simonecheng.github.io/JS-weird-parts-2/"/>
    <id>https://simonecheng.github.io/JS-weird-parts-2/</id>
    <published>2022-03-15T07:28:52.000Z</published>
    <updated>2023-07-15T13:26:14.143Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。</p><span id="more"></span><h2 id="Concept-Asides-名詞解釋"><a href="#Concept-Asides-名詞解釋" class="headerlink" title="Concept Asides 名詞解釋"></a>Concept Asides 名詞解釋</h2><h4 id="Dynamic-Typing-動態型別"><a href="#Dynamic-Typing-動態型別" class="headerlink" title="Dynamic Typing 動態型別"></a>Dynamic Typing 動態型別</h4><blockquote><p>You don’t tell the engine what type of data a variable holds, it figures it out while your code is running.<br>Variables can hold different types of values because it’s all figured out during execution.</p></blockquote><p>什麼是動態型別？</p><p>有很多程式語言是屬於強型別的語言，當使用強行別的語言時，在宣告變數的時候，同時也需要宣告這個變數的型別。但 JavaScript 不需要在宣告一個變數時，同時宣告該變數的型別， JavaScript Engine 會自己去判斷變數的型別。所以，JavaScript 是一種動態型別的語言。</p><h4 id="Primitive-Type-原始型別"><a href="#Primitive-Type-原始型別" class="headerlink" title="Primitive Type 原始型別"></a>Primitive Type 原始型別</h4><blockquote><p>A type of data that represents a single value.</p></blockquote><p>JavaScript 總共有六種原始型別，分別是：string、boolean、number、undefined、null、symbol。</p><h4 id="Operator-運算子"><a href="#Operator-運算子" class="headerlink" title="Operator 運算子"></a>Operator 運算子</h4><blockquote><p>A special function that is syntactically (written) differently.<br>Generally, operators take two parameters and return one result.</p></blockquote><p>當打出以下的程式碼時，我們會很直覺地認為會印出 7，但那是從人類的角度出發去做加減法，至於在 JavaScript Engine 當中是如何執行這段程式碼的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><p>其實對 JavaScript Engine 來說，他在背後做的事情比較像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> +(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// add the two variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三種不同的運算子表示方式 //</span></span><br><span class="line">+<span class="number">3</span> <span class="number">4</span> <span class="comment">// prefix notation</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> <span class="comment">// infix notation</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span>+ <span class="comment">// postfix notation</span></span><br></pre></td></tr></table></figure><p><code>+</code> 其實是一個 JavaScript 裡面本來就有的 function，所以當我們寫了 <code>+</code> 時，就是呼叫這個 function ，然後將兩個變數傳進去做加法，然後回傳出一個新的值。只是這個 function 是寫在兩個變數中間，也就是 <code>3 + 4</code>，這樣將運算子寫在中間的表示方式稱為 infix notation。</p><p>總之，在 JavaScript 中，運算子其實是一種 function，傳入兩個值，然後會回傳一個值。</p><h4 id="Coercion-強制轉型"><a href="#Coercion-強制轉型" class="headerlink" title="Coercion 強制轉型"></a>Coercion 強制轉型</h4><blockquote><p>Converting a value from one type to another.<br>This happens quite often in JavaScript because it’s dynamically typed.</p></blockquote><p>因為 JavaScript 是動態型別的語言，所以在程式執行的時候，它時不時會將寫好的變數或是值自動轉換型別，來看看以下簡易的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;Hello &#x27;</span> + <span class="string">&#x27;World&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure><p>在上述例子當中， a 和 b 都是同型別相加，所以我們可以知道 a 會印出 3，b 會印出 Hello World。但如果是不同型別之間的相加呢？比如以下的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">1</span> + <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><p>在這個範例中，和其他程式語言不同，JavaScript 不會因為這兩個值的型別不同而報錯，反而會嘗試將這兩個值轉成相同的型別，所以此時數字 1 會被轉型成字串 1，然後再與字串 2 相加，最後會印出字串 12。這個現象就是 Coercison。理解在 JavaScript 中有這個現象後，更容易在撰寫程式的時候避免許多因為轉型造成的錯誤。</p><div class="info">💡 <b>目前學到的轉型規則</b> 💡<br>當有兩個東西「相加」的時候，如果其中一個東西是字串，JavaScript 會嘗試將另一個東西也轉成字串。</div><h2 id="Operator-Precedence-and-Associativity"><a href="#Operator-Precedence-and-Associativity" class="headerlink" title="Operator Precedence and Associativity"></a>Operator Precedence and Associativity</h2><p>首先要來定義什麼是 Operator Precedence 和 Associativity：</p><blockquote><p><b>Operator Precedence:</b> which operator get called first.<br>Functions are called in order of precedence. (Higher precedence wins.)</p></blockquote><blockquote><p><b>Associativity:</b> what order operator functions get called in: left-to-right or right-to-left, when functions have the same precedence.</p></blockquote><p>簡單來說，當有多個運算子出現在一個運算式當中的時候，需要透過 Precedence 來決定要先執行哪個運算，如果每個運算子的優先順序都相同的話，再透過 Associativity 去決定是要從左到右或是從右到左執行優先級相同的運算子。</p><p>先來看看一個只需要用到 Precedence 的簡單範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span> * <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>在上述的程式碼當中，因為 <code>*</code> 的優先級比 <code>+</code> 高，所以 JavaScript Engine 會先做 <code>*</code> 再做 <code>+</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先做 *</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再做 +</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最後印出</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>JavaScript Engine 就是如上在執行運算子的運算，先將兩個值丟進一個運算的 function，然後回傳出一個新的值，再繼續做下一個運算子的運算，但也是因為這樣的運作方式，還有 JavaScript 本身是動態型別語言的關係，會導致一些奇怪的現象。</p><p>但在觀察這些奇怪的現象之前，先繼續來看看 Operator Precedence 和 Associativity 合在一起的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">a = b = c;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><p>在上述的例子當中，可以看到 <code>a = b = c</code> 這一行的運算子優先級是相同的（因為都是 &#x3D;，每個 &#x3D; 的優先級相同），接下來要看的就是 &#x3D; 的 Associativity，到 MDN 文件查之後，知道 &#x3D; 的 Associativity 是從右到左，所以 <code>a = b = c</code> 會從右到左執行，先執行 <code>b = c</code> 再執行 <code>a = b</code>，也就是說會先將 c 賦值給 b，再將 b 賦值給 c，所以最後 a、b、c 都會印出 4。</p><p>從以上兩個例子中，可以很清楚的知道 Operator Precedence 和 Associativity 的作用。</p><h2 id="Comparison-Operators"><a href="#Comparison-Operators" class="headerlink" title="Comparison Operators"></a>Comparison Operators</h2><p>在這個小節當中，講師提到當所有以上概念（Coercion、Operator Precedence and Associativity）合在一起的時候，JavaScript 會出現一些讓人困惑的現象。</p><p>第一個讓人困惑的地方是，JavaScript 在計算多個運算子的時候，運算的方式其實與人腦的運算方式並不同，所以會出現一些我們預期之外的狀況。</p><p>首先先觀察一個符合人們直覺的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上述的程式碼會印出 true，而這個也符合人們對數學運算的理解，1 的確是小於2，2 也的確是小於 3。但如果是以下的程式碼呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> &lt; <span class="number">2</span> &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>JavaScript 還是會印出 true，這時候就要來理解，當看到 3 &lt; 2 &lt; 1 的時候，JavaScript Engine 是以下面的步驟在運作的：</p><ol><li>根據 Operator Associativity 先執行 3 &lt; 2，得到 false</li><li>進行 false &lt; 1 的運算</li><li>嘗試把 false 轉型成 number，所以 false &lt; 1 變成 0 &lt; 1</li><li>進行 0 &lt; 1 的運算</li><li>得到 true，然後印出來</li></ol><p>從以上步驟可以知道，JavaScript Engine 在進行各種運算子運算的時候，與我們平常在算數學時使用的計算方式不同。</p><hr><p>第二個讓人困惑的地方是有關 undefined、false、null 這三個型別如果被轉型成數字的話，我們會預期都是 0。但實際上並不是，undefined 會被轉型成 NaN，false、null 才會被轉型成數字 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><p>第三個讓人困惑的地方是，如果使用運算子，特別是 <code>==</code> 的時候（因為使用兩個等於會先轉型才比較），又會發生讓人困惑的狀況，比如以下幾個例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> &lt; <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由於使用 <code>==</code> 會導致互相比較的值先轉型才進行比較，但我們很多時候並沒有辦法準確預測 JavaScript Engine 會將值轉型成什麼型別，可能會造成小錯誤。</p><p>在 JavaScript 當中，還有另外一個運算子 <code>===</code> 也可以用來比較兩個值是否相等。使用 <code>===</code> 時並不會使想要比較的值被轉型，會先比較型別是否相同然後才比較兩者的值，如果型別不同便會直接回傳 false，所以可以盡量使用 <code>===</code> 會比較好。</p><h2 id="什麼時候用到了-Coercion？"><a href="#什麼時候用到了-Coercion？" class="headerlink" title="什麼時候用到了 Coercion？"></a>什麼時候用到了 Coercion？</h2><p>其實平常在寫 code 的時候，我們也默默用到了很多轉型的概念，比如說以下的 react 的使用情境就是利用當 state 是空字串時會轉型成 false，非空字串會轉型成 true ，來判斷要顯示什麼樣的畫面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="title class_">Component</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setState</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">    &#125;, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="comment">// 這邊的 state ? 就用到了轉型 //</span></span><br><span class="line">        &#123;state ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;state&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>There is no state<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN 文件 - Operator precedence</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">MDN 文件 - Equality comparisons and sameness</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://simonecheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【克服JS的奇怪部分】Execution Contexts &amp; Lexical Environments</title>
    <link href="https://simonecheng.github.io/JS-weird-parts-1/"/>
    <id>https://simonecheng.github.io/JS-weird-parts-1/</id>
    <published>2022-03-11T10:11:05.000Z</published>
    <updated>2023-07-15T13:26:14.143Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。</p><span id="more"></span><h2 id="Concept-Asides-名詞解釋"><a href="#Concept-Asides-名詞解釋" class="headerlink" title="Concept Asides 名詞解釋"></a>Concept Asides 名詞解釋</h2><h4 id="Syntax-Parser-語意分析"><a href="#Syntax-Parser-語意分析" class="headerlink" title="Syntax Parser 語意分析"></a>Syntax Parser 語意分析</h4><blockquote><p> A program that reads your code and determines what it does and if its grammar is valid.</p></blockquote><p>當我們在寫 JavaScript 的時候，寫完之後其實電腦是看不懂的，而是需要透過編譯器(complier) 來翻譯成電腦看得懂的語言，才能夠幫我們執行我們想要實現的功能。</p><p><img src="/../assets/complie-flowchart.png"></p><h4 id="Lexical-Environment-詞彙環境"><a href="#Lexical-Environment-詞彙環境" class="headerlink" title="Lexical Environment 詞彙環境"></a>Lexical Environment 詞彙環境</h4><blockquote><p> Where something sits physically in the code you write.</p></blockquote><p>當我們在寫 JavaScript 的時候，Lexical Environment 關注的是這個 function 被寫在這個程式中的哪個部分，以及它周遭的環境是什麼，有了 Lexical Environment，可以讓 Syntax Parser 更容易解析整個程式碼，比如說以下的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a  = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 這個變數是存在於 Greeting 這個函數的環境中</span></span><br></pre></td></tr></table></figure><p>並不是所有的程式語言都有 Lexical Environment，但 JavaScript 有。</p><h4 id="Execution-Context-執行環境"><a href="#Execution-Context-執行環境" class="headerlink" title="Execution Context 執行環境"></a>Execution Context 執行環境</h4><blockquote><p>A wrapper to help manage the code that is running.<br>There are lots of lexical environments. Which one is currently running is managed via execution contexts. It can contain things beyond what you’ve written in your code.</p></blockquote><p>當我們寫好程式碼之後，我們該如何知道它是按照什麼樣的順序被電腦執行的？整個程式碼的執行流程是如何安排的？這就是 Execution Context 需要做的工作。</p><h4 id="Name-Value-Pair"><a href="#Name-Value-Pair" class="headerlink" title="Name&#x2F;Value Pair"></a>Name&#x2F;Value Pair</h4><blockquote><p>A name which maps to a unique value.<br>The name may be defined more than once, but only can have one value in any given <strong>context</strong>.<br>That value may be more name&#x2F;value pairs.</p></blockquote><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><blockquote><p>A collection of name&#x2F;value pairs.<br>The simplest definition when talking about <strong>JavaScript</strong>.</p></blockquote><h4 id="JavaScript-and-‘undefined’"><a href="#JavaScript-and-‘undefined’" class="headerlink" title="JavaScript and ‘undefined’"></a>JavaScript and ‘undefined’</h4><p>直接來看看兩個不同的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 印出 undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 報錯：印出 Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>我們可以知道範例一和範例二都印出了東西，但 undefined 和 is not defined 從英文字面上來看不是一樣的意思嗎？其實這兩者對 JavaScript 來說是兩個不一樣的東西。</p><p><strong>undefined</strong> 在這裡的意思是：JavaScript 已經為這個變數預留了一個記憶體的位置，但因為這個變數還沒有被賦值，所以 JavaScript 就先暫時設了一個初始值給你，然後這個初始值叫做「undefined」。所以我們可以把 undefined 理解為「尚未設定的值」。</p><p><strong>is not defined</strong> 的意思則是：JaveScript 在記憶體位置當中並沒有尋找到該變數，所以它就會報錯，告訴我們 <code>Uncaught ReferenceError: a is not defined</code>。</p><h4 id="Single-Threaded-單執行緒"><a href="#Single-Threaded-單執行緒" class="headerlink" title="Single Threaded 單執行緒"></a>Single Threaded 單執行緒</h4><blockquote><p>One command at a time.<br>Under the hood of the browser, maybe not.</p></blockquote><p>JavaScript 是一個單執行緒的語言，也就是說 JavaScript 在執行的時候，一次只能做一件事情。但是如果我們是在 browser 這個環境之下執行 JavaScript，browser 本身可以幫我做到多執行緒的事情，但是就像開頭提到的 JavaScript 本身是一個單執行緒的語言。</p><h4 id="Synchrnous-Execution-同步執行"><a href="#Synchrnous-Execution-同步執行" class="headerlink" title="Synchrnous Execution 同步執行"></a>Synchrnous Execution 同步執行</h4><blockquote><p>One at a time and in order.</p></blockquote><p>JavaScript 是同步執行的，也就是說做完一件事情，才會做下一件事情，而且會按照事情排好的順序依序做下去。</p><h2 id="The-Global-Environment-and-The-Global-Object"><a href="#The-Global-Environment-and-The-Global-Object" class="headerlink" title="The Global Environment and The Global Object"></a>The Global Environment and The Global Object</h2><p>當 JavaScript 在執行的時候，它一定會在一個全域執行環境 (Global Environment) 當中執行，在這個環境當中會有一個全域物件 (Global Object)，以及一個很特殊的 variable 「this」。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────┐</span><br><span class="line">│ Execution Context(Global)                                 │</span><br><span class="line">│      ┌──────────────────┐     ┌───────────────────┐       │</span><br><span class="line">│      │                  │     │                   │       │</span><br><span class="line">│      │   Global Object  │     │        this       │       │</span><br><span class="line">│      │                  │     │                   │       │</span><br><span class="line">│      └──────────────────┘     └───────────────────┘       │</span><br><span class="line">└───────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>當我們在瀏覽器中執行 JavaScript 時，瀏覽器是一個 runtime，所以此時 JavaScript 所在的 Global Execution Context，就是瀏覽器的全域環境，在這個環境裡有一個 Global Object 叫做「window」。當我們在這個全域環境當中直接打 <code>console.log(this);</code> 的時候，<code>this</code> 指的就是 <code>window</code>。至於當我們在 node.js 當中執行 JavaScript 時，此時的 Global Object 和 this 就會是 node.js 設定好的。</p><p>假設目前在瀏覽器中使用 <code>var</code> 宣告一個變數 a ，而且這個變數 a 等於 1 時，其實就是在瀏覽器當中的 Global Object 中建立一個 Name&#x2F;Value Pair，所以可以透過 <code>window.a</code> 這個指令來找到剛才宣告的變數 a。如以下程式碼所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><div class="info">es6 新增了兩個新的宣告方式 <code>const</code> 以及 <code>let</code>，這兩個的用法與 <code>var</code> 不同，如果在全域環境使用 <code>const</code> 或 <code>let</code>，並不會在 Global Object 中建立一個 Name/Value Pair，避免了一些使用 <code>var</code> 會產生的問題。這三者的比較可能會之後再寫一篇筆記做更深入探討。</div><h2 id="The-Execution-Context"><a href="#The-Execution-Context" class="headerlink" title="The Execution Context"></a>The Execution Context</h2><h4 id="Creation-and-Hoisting"><a href="#Creation-and-Hoisting" class="headerlink" title="Creation and Hoisting"></a>Creation and Hoisting</h4><p>在開始說明 JavaScript Engine 如何創建執行環境時，我們先來看看 JavaScript 的特殊現象「Hoisting」。首先來看看以下範例一的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>將上述的程式碼執行之後，我們可以很輕鬆也如常的預期會先印出 <code>Called b!</code>，再印出　<code>Hello World!</code>，但如果我們把程式碼改成下面這樣呢？</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程式碼是從上到下，一行一行依序執行的話，照理來說在跑第一行的時候就會報錯，因為我們在尚未宣告變數和函數時，就對該變數或函數進行呼叫。但在 JavaScript 裡面卻不是這樣，將以上程式碼執行之後，JavaScript會幫我們印出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Called</span> b!</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>JavaScript 並沒有幫我們報錯，反而印出東西來，這是因為在這當中存在著「Hoisting」的現象。很多網路上對「Hoisting」的解釋大部分都是：想像 JavaScript Engine 將所寫的宣告的程式碼（但如果是宣告變數的話，只會提升宣告的變數，不會連同賦值的部分一起提升）提升到最上面的地方，比如想像範例二的程式碼變成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以我們才會得到印出 <code>Called b!</code> 和 <code>undefined</code> 的結果。但其實 JavaScript Engine 並不會真的去調動你所寫的程式碼的位置，所以「<strong>想像 JavaScript Engine 將所寫的宣告的程式碼（但如果是宣告變數的話，只會提升宣告的變數，不會連同賦值的部分一起提升）提升到最上面的地方</strong>」這樣的描述雖然能夠解釋 Hoisting 這個現象，但它並沒有精確地去描述 JavaScript Engine 在 Hoisting 的時候實際上到底做了什麼。</p><p>所以 JavaScript Engine 到底做了什麼？在 Execution Context 被創建之後，除了同時創建了 Global Obeject、this 之外，還會同時先預留記憶體位置給變數與函式。</p><p>這個「<strong>先預留記憶體位置給變數與函式</strong>」的動作就是 Hoisting。但要特別注意的地方是：當宣告的 function 被 hoisted 的時候，除了 funciton 的名稱會被 hoisted，整個 funciton 裡面的 code 也會被 hoisted。但如果是使用 <code>var</code> 來宣告變數的時候，只有變數的名稱會被 hoisted，賦值這個動作並不會被 hoisted，然後 JavaScript Engine 會將所有被 hoisted variable 的初始值設為 undefined。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                                    │</span><br><span class="line">│  Execution Context is Created (Creation Phase)                                     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌────────────────────┐    ┌───────────────────┐      ┌──────────────────┐     │</span><br><span class="line">│      │      Global        │    │                   │      │      Outer       │     │</span><br><span class="line">│      │                    │    │      &#x27;this&#x27;       │      │                  │     │</span><br><span class="line">│      │      Object        │    │                   │      │   Environment    │     │</span><br><span class="line">│      └────────────────────┘    └───────────────────┘      └──────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌───────────────────────────────────────────────────────────────────────┐     │</span><br><span class="line">│      │      Set up Memory Space for Variables and Functions                  │     │</span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      │            &quot;Hoisting&quot;                                                 │     │</span><br><span class="line">│      └───────────────────────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><div class="warning">盡量在執行函數或使用變數之前先宣告他們，不要過度依賴於 Hoisting 的現象。因為你不知道你宣告的變數有沒有可能會變成 undefined。</div><h4 id="Code-Execution"><a href="#Code-Execution" class="headerlink" title="Code Execution"></a>Code Execution</h4><p>JavaScript 在執行程式碼的時候就比較好理解了，不會有什麼 Hoisting 啦之類的奇怪的事情發生，就是我們寫好的程式碼會被 JavaScript Engine 在它該在的環境當中被一行一行的執行。但要特別注意的是，JavaScript 是單執行緒的語言喔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                                    │</span><br><span class="line">│  Execution Context is Created (Execution Phase)                                    │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌────────────────────┐    ┌───────────────────┐      ┌──────────────────┐     │</span><br><span class="line">│      │      Global        │    │                   │      │      Outer       │     │</span><br><span class="line">│      │                    │    │      &#x27;this&#x27;       │      │                  │     │</span><br><span class="line">│      │      Object        │    │                   │      │   Environment    │     │</span><br><span class="line">│      └────────────────────┘    └───────────────────┘      └──────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌───────────────────────────────────────────────────────────────────────┐     │</span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      │                            Runs Your Code                             │     │  </span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      └───────────────────────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Function-Invocation-and-the-Execution-Stack-Call-Stack"><a href="#Function-Invocation-and-the-Execution-Stack-Call-Stack" class="headerlink" title="Function Invocation and the Execution Stack(Call Stack)"></a>Function Invocation and the Execution Stack(Call Stack)</h2><blockquote><p><strong>nvocation</strong>: running a function<br>In JavaScript, we can use parenthesis() to invocate function.</p></blockquote><p>當使用 JavaScript 呼叫函式的時候，底層做了什麼樣的事情？換句話說，函式被我們呼叫以後，JavaScript 是怎麼執行這些函式的？我們可以試著用以下的程式碼來舉例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>當我們開始執行以上的程式碼的時候，首先會先在 Execution Stack 裡面建立一個 Global Execution Context，接著當程式碼一行一行跑下來跑到 <code>a()</code> 然後執行 <code>a</code> 這個函式的時候，JavaScript 會為這個函數創建它的 Execution Context，並將它放到 Execution Stack（執行堆疊）當中，疊在 Global Execution Context 上面。</p><p>然後因為 <code>a()</code> 函式被執行了，連帶 <code>a()</code> 當中的 <code>b()</code> 也被執行，所以 JavaScript 也為 <code>b()</code> 函式創建了一個 Execution Context，而 <code>b()</code> 的 Execution Context 會疊在 <code>a()</code> 上面。</p><p>在 Execution Stack 當中函式的執行順序是由上往下執行的，也就是說，以此範例為例，會先執行 <code>b()</code>、在執行 <code>a()</code>，當 <code>b()</code> 執行完之後，<code>b()</code>就會離開執行堆疊（英文稱作 pop off），以此類推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │ ────► Execution Stack</span><br><span class="line">│ │             b()                 │ │</span><br><span class="line">│ │      Execution Context          │ │</span><br><span class="line">│ │     (create and execute)        │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │</span><br><span class="line">│ │            a()                  │ │</span><br><span class="line">│ │      Execution Context          │ │</span><br><span class="line">│ │     (create and execute)        │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │</span><br><span class="line">│ │    Global Execution Context     │ │</span><br><span class="line">│ │  (created and code is executed) │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">└─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Functions-Context-and-Variables-Environments"><a href="#Functions-Context-and-Variables-Environments" class="headerlink" title="Functions, Context, and Variables Environments"></a>Functions, Context, and Variables Environments</h2><blockquote><p><strong>Variable Environment</strong>: where the variables live and how they realte to each other in memory</p></blockquote><p>在每個 Execution Context 被創建之後，同時該 Execution Context 也會有一個自己的 Variable Environment。我們可以透過以下的程式碼為例，來說明 Variable Environment 在 JavaScript 中是如何被建立的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><p>當上述程式碼被執行之後，myVar 會是什麼值？程式碼執行後，JavaScript Engine 會分別在 Global、a()、b() 各自的 Execution Context 中各建立一個 Variable Environment，所以 myVar 在不同的 Execution Context 當中就會有不同的值，需要先觀察目前程式碼執行到哪邊，再去判斷 myVar 目前的值。如下圖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │  ───────► Execution Stack</span><br><span class="line">│   │                  b()                          │    │</span><br><span class="line">│   │                                               │    │</span><br><span class="line">│   │           Execution Context       ┌─────────┐ │    │</span><br><span class="line">│   │                                   │   myVar │ │    │</span><br><span class="line">│   │          (create and execute)     │undefined├─┼────┼──────┐</span><br><span class="line">│   └───────────────────────────────────┴─────────┴─┘    │      │</span><br><span class="line">│                                                        │      │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │      │</span><br><span class="line">│   │                  a()                          │    │      │</span><br><span class="line">│   │                                               │    │      │</span><br><span class="line">│   │           Execution Context         ┌───────┐ │    │      │</span><br><span class="line">│   │                                     │ myVar │ │    │      │</span><br><span class="line">│   │          (create and execute)       │   2   ├─┼────┼──────┼─────► Variable Environment</span><br><span class="line">│   └─────────────────────────────────────┴───────┴─┘    │      │</span><br><span class="line">│                                                        │      │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │      │</span><br><span class="line">│   │                                               │    │      │</span><br><span class="line">│   │      Global Execution Context                 │    │      │</span><br><span class="line">│   │                                     ┌───────┐ │    │      │</span><br><span class="line">│   │    (created and code is executed)   │ myVar │ │    │      │</span><br><span class="line">│   │                                     │   1   ├─┼────┼──────┘</span><br><span class="line">│   └─────────────────────────────────────┴───────┴─┘    │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="The-Scope-Chain"><a href="#The-Scope-Chain" class="headerlink" title="The Scope Chain"></a>The Scope Chain</h2><p>還記得我們在前面提到，程式碼執行之後，會為每個執行的函數建立自己的 Execution Context、自己的 Variable Environment。現在我們要談到，當程式碼執行後除了會建立上述提到的部分，還會建立一個 Outer Environment，意思就是指會建立一個對外的 Scope 參照。</p><p>總結來說，當一個 Execution Context 被建立的時候，裡面會有以下幾種東西：</p><ul><li>Global Object</li><li>this</li><li>Hoisting</li><li>Outer Environment</li><li>Variable Environment</li></ul><p>所以，建立一個對外的 Scope 參照是什麼意思？</p><p>如果用文字敘述來說明的話，指的是 JavaScript Engine 會去檢查該程式碼（比如說某個 function）的 Lexical Environment，也就是去檢查某個 funciton 的所在位置，再將該 function 所在位置的 variable environment 當作參照。</p><p>比如某個 function 是在全域環境中宣告的，那麼當 JavaScript Engine 在執行該 function 的時候，除了會建立 function 自己的 variable environment 之外，也會去參照這個 function 所在位置的 variable environment，也就是全域環境的 variable environment。</p><p>而上述提到的這種行為，便會導致一個稱為「Scope Chain」的現象發生。我們現在可以來看看以下幾個不同的程式碼，來更加了解 Scope Chain。</p><hr><p>首先來觀察狀況一，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在全域，於是 JavaScript Engine 又在全域環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現有，於是便印出 <code>1</code>。</p><hr><p>接下來來看看狀況二，在狀況二的程式碼中，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在 <code>a function</code> 裡面宣告的，於是 JavaScript Engine 又在 <code>a function</code> 的執行環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現有，於是便印出 <code>２</code>。</p><hr><p>接下來來看看狀況三，在狀況三的程式碼中，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在 <code>a function</code> 裡面宣告的，於是 JavaScript Engine 又在 <code>a function</code> 的執行環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現沒有，於是又再繼續檢查 <code>a funciton</code> 是在哪個環境被宣告的，檢查之後發現是在全域環境，於是又再繼續檢查全域環境有沒有變數 <code>myVar</code>，然後終於發現有，於是便印出 <code>1</code>。</p><hr><p>從以上三個狀況中，可以看到以下幾個步驟：</p><ol><li>某個函式被呼叫並執行</li><li>JavaScript Engine 檢查該函式的 Lexical Context，確定它的 Outer Environment（也就是函式被宣告的環境）。</li><li>如果某個函式呼叫了一個自己的 Variable Environment 沒有的變數，JavaScript Engine 就會開始往 Outer Environment 的 Variable Environment 檢查有沒有那個變數。</li><li>一直重複步驟 3，直到找到那個變數，或是找到最後發現沒有那個變數</li></ol><p>這種不斷地往 Outer Environment 尋找 Variable 的現象就稱為「Scope Chain」。</p><h2 id="Scope-ES6-and-let"><a href="#Scope-ES6-and-let" class="headerlink" title="Scope, ES6, and let"></a>Scope, ES6, and let</h2><blockquote><p>Scope: where a variable is available in your code.</p></blockquote><p>在 ES6 以前，若想要宣告一個變數，只有 <code>var</code> 可以用，但在 ES6 公布之後，目前有 <code>var</code>、<code>const</code>、<code>let</code> 可以用來宣告變數。</p><p>這三者之間也有些許不同。用 <code>let</code> 和 <code>const</code> 宣告變數後，那個變數所在的 Scope 是一個 block Scope（例如用<code>&#123;&#125;</code>圍起來就是一個 block），而用 <code>var</code> 則會將變數宣告在 Function Scope 當中。</p><p>用 <code>var</code>、<code>const</code>、<code>let</code> 都會有 Hoisting 的現象，只是使用 <code>var</code> 時，會給予變數一個 undefined 的初始值，但如果是 <code>const</code>、<code>let</code> 的話，則是會讓變數存在暫時死區無法使用，然後報錯。</p><table><thead><tr><th></th><th><code>var</code></th><th><code>const</code></th><th><code>let</code></th></tr></thead><tbody><tr><td>作用域</td><td>函式作用域</td><td>區塊作用域</td><td>區塊作用域</td></tr><tr><td>Hoisting</td><td>undefined</td><td>進入暫時死區，會報錯</td><td>進入暫時死區，會報錯</td></tr></tbody></table><h2 id="What-about-Asynchronous-Callbacks"><a href="#What-about-Asynchronous-Callbacks" class="headerlink" title="What about Asynchronous Callbacks?"></a>What about Asynchronous Callbacks?</h2><p>在前面的影片有提到 JavaScript 是一個單執行緒、同步的語言（一次只做一件事情），但是在瀏覽器當中卻可以做到非同步（一次做很多件事情），這到底是如何辦到的？是因為有瀏覽器這個執行的環境，它可以先做一些非同步的處理，然後再將處理好的函數一一丟到 JavaScript Engine 當中去執行。</p><p>瀏覽器處理非同步的過程有個專有名詞稱為 Event Loop，也許之後可以再寫一篇筆記來記錄瀏覽器當中的 Event Loop 是如何運作的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://simonecheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【HTML】metadata、meta 知多少</title>
    <link href="https://simonecheng.github.io/metadata/"/>
    <id>https://simonecheng.github.io/metadata/</id>
    <published>2022-01-29T09:55:38.000Z</published>
    <updated>2023-07-15T13:26:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>今天想要研究的主題是，網頁前端世界裡的三本柱 ── <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 之中的 <code>HTML</code>。雖然 <code>HTML</code> 並非如同 <code>JavaScript</code> 有很多程式語言相關的主題與議題能夠探討，但是也是有一些有趣的主題值得研究和探索。</p><span id="more"></span><p>之前在寫 side project 或是技術面試被問到該如何優化 SEO 時，當時只有辦法大概回答出可以透過 <code>HTML</code> 當中的 metadata 去優化 SEO，但是並不清楚 metadata 實際上有哪些用法，或是可以做到哪些事情，所以這次想要試著以一種更詳細和全面的角度來理解 <code>HTML</code> 當中會使用到的 metadata 和 <code>&lt;meta&gt;</code> 這兩個東西。（當然有機會的話，之後也想要寫一個 SEO 的系列文來理解 SEO 和知道如何優化它）</p><p>本文架構如下：</p><ul><li><strong>metadata 是什麼？</strong> → 首先會先定義 metadata 是什麼</li><li><strong>metadata 有哪些？</strong> → 接著解釋 metadata 在 <code>HTML</code> 當中的應用</li><li><strong>淺談 <code>&lt;meta&gt;</code></strong> → 最後會對 <code>&lt;meta&gt;</code> 這個用法做更深入的研究</li></ul><p>你可能要有的先備知識：</p><ul><li>知道 <code>HTML</code> 是什麼</li><li>了解 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 的差別</li></ul><h2 id="metadata-是什麼？"><a href="#metadata-是什麼？" class="headerlink" title="metadata 是什麼？"></a>metadata 是什麼？</h2><p>首先可以先從現有的網路資源當中，去尋找 metadata 的定義。在 MDN 文件當中，解釋了什麼是 metadata：</p><blockquote><p><strong>Metadata</strong> is — in its very simplest definition — data that describes data. For example, an HTML document is data, but HTML can also contain metadata in its <code>&lt;head&gt;</code> element that describes the document — for example who wrote it, and its summary.</p></blockquote><p>直接翻譯的話，metadata 的意思就是「描述資料」的資料，這樣子聽起來可能還是一頭霧水，但如果我們以一個實際的例子來說明的話，可能會清楚許多。</p><p>假設現在有一個猜拳遊戲網頁的 <code>HTML</code> 檔，架構如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-Hant-TW&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- metadata, 使用者不會看到，但是會提供這個 HTML 檔相關的資訊，例如以下四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;猜拳遊戲&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rock_Paper_Scissors Game<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用者會看到的內容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常在 <code>&lt;body&gt;</code> 這個標籤中會放滿希望讓使用者看到的畫面；另外將描述這個網頁的資訊，比如這個網頁的作者、這個網頁的用途、這個網頁的編碼方式、要套用的 <code>css</code> 檔、要套用的 <code>JavaScript</code> 檔等等，放在 <code>&lt;head&gt;</code> 這個標籤當中。</p><p>這些放在 <code>&lt;head&gt;</code> 當中的資訊，並且用來描述這個 <code>HTML</code> 網頁檔是要用來做什麼、或是要運行什麼東西，都可以稱之為 metadata。通常這些 metadata 的資訊會被搜尋引擎的爬蟲爬取並解析，於是我們可以在這裡很簡單地暴力推測：如果 metadata 寫得越完整，對 SEO 的幫助越大，也可以說是優化 SEO 的方法之一。</p><h2 id="metadata-有哪些？"><a href="#metadata-有哪些？" class="headerlink" title="metadata 有哪些？"></a>metadata 有哪些？</h2><p>在上一個小節理解 metadata 的定義之後，那接下來的問題就是：實際上要如何在 <code>HTML</code> 當中寫出 metadata 呢？這也是本小節試圖回答和整理的問題。</p><h3 id=""><a href="#" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h3><p>在每個 <code>HTML</code> 檔的 <code>&lt;head&gt;</code> 當中，基本上一定都會有 <code>&lt;title&gt;</code> 這個標籤（tag），它的語法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert Title Here | Follow it with the Website Name if you Wish<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>藉由 <code>title</code> 這個標籤，可以讓搜尋引擎知道這個網頁的名稱，並將它顯示在搜尋結果頁上面。或是也可以在瀏覽器的頁籤上看到 <code>&lt;title&gt;</code> 的內容，讓使用者知道自己目前在哪個網頁，比如說進到臉書首頁時，在瀏覽器頁籤上看到 Facebook 字樣，是因為 <code>&lt;title&gt;Facebook&lt;/title&gt;</code> 的緣故。 </p><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h3><p><code>&lt;link&gt;</code> 這個標籤的用途蠻多元的，目前我自己最常用到的是將 <code>CSS</code> 檔引入到 <code>HTML</code> 當中，讓網頁上的元素可以套用樣式，除此之外還有一些其他的用途，例如：加入網頁的 Logo、用標準網址（Canonical URL）整合重複性的網址等等。</p><h4 id="將-CSS-檔引入（Load-Stylesheets）"><a href="#將-CSS-檔引入（Load-Stylesheets）" class="headerlink" title="將 CSS 檔引入（Load Stylesheets）"></a>將 <code>CSS</code> 檔引入（Load Stylesheets）</h4><p>平常在撰寫網頁時，除了需要 <code>HTML</code> 來建立網頁的架構，也會需要 <code>CSS</code> 來讓網頁上的內容套用美美的樣式，通常會將 <code>CSS</code> 樣式寫在另外一個檔案裡，再引入到 <code>HTML</code> 當中，可以使用以下語法來引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;[fileName].css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="加入網頁-Logo（Add-a-Favicon）"><a href="#加入網頁-Logo（Add-a-Favicon）" class="headerlink" title="加入網頁 Logo（Add a Favicon）"></a>加入網頁 Logo（Add a Favicon）</h4><p>打開一個網頁時，頁籤上除了會顯示 <code>&lt;title&gt;</code> 中的網頁名稱之外，也會看到在網頁名稱前面有個小小的 Logo（叫做 favicon），這個小小的 Logo 可以透過以下方式來新增到網頁當中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>隨著網路不斷演進，目前客戶端有多種瀏覽器和設備，所以 favicon 為了演進的需要也提供的多種置入的方式，比如不一定要用 .ico 的格式， .png、.svg 也可以，每個瀏覽器或是設備當中看到的 favicon 最佳大小可能也不相同。由於本文學習和研究的重心主要是在 <code>&lt;meta&gt;</code> ，對這部分的內容可能不夠詳盡，若想深入了解的話，也許可以參考這則在 stackoverflow 上的討論：<a href="https://stackoverflow.com/questions/23849377/html-5-favicon-support">HTML 5 Favicon - Support?</a>。</p><h4 id="標準網址-（Canonical-URL）"><a href="#標準網址-（Canonical-URL）" class="headerlink" title="標準網址 （Canonical URL）"></a>標準網址 （Canonical URL）</h4><p>假設目前有以下的網址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/</span><br><span class="line">http://www.example.com/index.html</span><br><span class="line">http://example.com/</span><br><span class="line">http://example.com/index.html</span><br></pre></td></tr></table></figure><p>但其實這些網址連到的都是同一個網頁，或是在不同網頁上提供相似度極高的內容（例如：行動版和電腦版的網頁，兩者是不同網址但內容幾乎相同）。Google 搜尋引擎便會將這些不同的網址視為相同網頁的重複版本，從中選出一個網址作為「標準」版本進行檢索，然後將其他網址判定為「重複」網址並降低搜尋引擎爬取的頻率。</p><p>如果我們沒有設定一個標準網址的話，Google 搜尋引擎本身就會自己幫我們決定一個標準網址。為了避免這件事情發生，我們其實可以透過以下語法來設定一個自己想要的標準網址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;canonical&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>這也是 <code>&lt;link&gt;</code> 的用途之一。有關標準網址相關資訊，可以參考 Google 搜尋中心的說明：<a href="https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls">整合重複的網址</a>。更多有關 <code>&lt;link&gt;</code>詳細的屬性解說可以參考 MDN 文件：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link">link: The External Resource Link element</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types">Link types</a>。</p><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;base&gt;"></a><code>&lt;base&gt;</code></h3><p><code>&lt;base&gt;</code> 標籤主要是控制網頁的連結屬性，可以指定網頁的連結根目錄，也可以指定網頁超連結的開啟方式，屬性有 href、target。我們可以直接來看以下兩個範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>這是標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- HTML base href, target 範例設定 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;products&quot;</span>&gt;</span>產品資訊<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about-us&quot;</span>&gt;</span>關於我們<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;faq&quot;</span>&gt;</span>問與答<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>這是標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/products&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>產品資訊<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/about-us&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>關於我們<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/faq&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>問與答<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上兩個程式碼達成的效果其實是相同的。上面的程式碼有使用 <code>&lt;base&gt;</code>，直接指定整個網頁的連結開頭，還有這個網頁按下超連結時會使用開啟新分頁的方式，所以就不需要針對每一個 <code>&lt;a&gt;</code> 進行處理；下面的程式碼沒有使用 <code>&lt;base&gt;</code>，所以便會針對每一個 <code>&lt;a&gt;</code> 進行處理。</p><p>另外需要注意的是：只要有設定 <code>&lt;base&gt;</code> 的 <code>href</code>，任何網頁中的連結都會被它給覆蓋過去。更多有關 <code>&lt;base&gt;</code> 的用法可以參考這些資源：<a href="https://seanacnet.com/html/base-html/">base html 標籤是什麼? html tag 設定網頁連結 - SEAN 工作版</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">base: The Document Base URL element - MDN</a>。</p><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><p>可以使用 <code>&lt;script&gt;</code> 這個標籤來引入 JavaScript，執行一些這個 <code>HTML</code> 網頁所需要的程式碼，比如 CDN 、Gooogle Analytics、網頁互動邏輯等等，可以使用以下兩種不同的方式引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：直接將 JavaSript 寫在裡面</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"> <span class="comment">&lt;!-- 要執行的 JavaScript --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 方法二：插入一個 JavaScript 檔</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;[folder_name]/[file_name].js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外在使用 <code>&lt;script&gt;</code> 這個標籤時，可以特別注意某些屬性是怎麼使用的，比如說： <code>defer</code> 和 <code>async</code> 的差別、<code>type=&quot;module&quot;</code> 怎麼用等等。更多詳細的屬性解說可以參考 MDN 文件：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">script: The Script element</a>。</p><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h3><p>除了上述使用到的標籤之外，可能也還有很多 metadata 需要寫進 <code>HTML</code> 檔裡，比如這個網頁的編碼方式、這個網頁的作者、這個網頁的描述等等，這些都可以使用 <code>&lt;meta&gt;</code> 這個標籤來實現。簡單來說，除了前面提到的標籤以及它們的用途之外，其他的 metadata 都可以寫在 <code>&lt;meta&gt;</code> 這個標籤中，在下一個部分會針對 <code>&lt;meta&gt;</code> 的屬性做更詳細的理解與介紹。</p><h2 id="淺談"><a href="#淺談" class="headerlink" title="淺談 &lt;meta&gt;"></a>淺談 <code>&lt;meta&gt;</code></h2><p>在這個部分會一一介紹幾個 <code>&lt;meta&gt;</code> 當中常用到的 attribute，了解這些 attribute 的用途。</p><h3 id="name、content"><a href="#name、content" class="headerlink" title="name、content"></a>name、content</h3><p>首先第一個登場的 attribute 就是 name 和 content。name 和 content 可以用來描述一個網站的資訊，像是這個網站的作者、這個網站的描述、圖片等等，通常這兩者可以寫在一起，比如下面的範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Simone&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span> <span class="attr">content</span>=<span class="string">&quot;xxx.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這三行程式碼如果直接寫成中文的話，大概呈現的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：Simone</span><br><span class="line">網站描述：This is my page</span><br><span class="line">圖片：xxx.jpg</span><br></pre></td></tr></table></figure><p>同時，這些資訊也可以讓搜尋引擎查詢，讓搜尋引擎知道這個網頁到底是什麼樣的網頁。</p><p>另外有一個可能需要特別注意的地方：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html, css, javascript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以往 name 有一個 keywords 的寫法，表示這個網站會用到的關鍵字，提供搜尋引擎尋找，但目前 Google 有說搜尋引擎目前不會查詢 keywords 了。所以如果有需要的話，可以改成寫在 meta description 當中。</p><h3 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h3><p>charset 這個 attribute 是用來設定該網頁會用何種方式來進行編碼，比如以下的範例使用 utf-8 方式還進行編碼，也是目前網頁常用到的編碼方式。HTML5 預設的編碼方式也是 utf-8。（編碼的方式有非常多種，也許之後也可以寫筆記來研究研究）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><p>http-equiv 會告訴瀏覽器該如何處理這份文件。</p><p>在對伺服器發出 request 之後，伺服器會回傳 reponse，通常 response 裡面會有 headers。在 <code>meta</code> 當中使用 http-equiv 時，http-equiv 所包含的資訊會類似於 reponse 傳回來的 headers，比如下面兩個範例的意思其實是差不多的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- metadata in HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 伺服器回傳的 headers</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>所以 http-equiv 可以理解成 HTTP response headers equivalent，當中的 equiv 其實就是 equivalent 的意思。</p><p>不過，HTTP response 不是都會有 headers ？為什麼還要在 HTML 文件放入類似的資訊？有可能使用者無法直接獲得 HTTP response headers，所以就需要靠 http-equiv 的資訊了。</p><p>http-equiv 還有另外一個用法是 refresh，可以設定幾秒過後重新整理，或是幾秒過後重新導向某個網址，比如以下的程式碼：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3 秒後重新整理頁面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 5 秒後導向 http://www.example.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5; url=http://www.example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>目前 HTML5 請直接使用 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>， <code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code> 是 HTML4 在用的。</p></blockquote><h3 id="Open-Graph"><a href="#Open-Graph" class="headerlink" title="Open Graph"></a>Open Graph</h3><p>平常在各個社群網站分享網址的時候，除了將一串網址貼到貼文上面之外，是不是還會看有一個區塊，上面會有你分享的網站的標題、敘述、圖片等等。</p><p>這部分就是用 Open Graph 辦到的，讓使用者在社群當中分享網站時，可以顯示美美的畫面，且只需要在 <code>&lt;meta&gt;</code> 當中寫下以下程式碼就可以辦到了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Open Graph protocol&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;website&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:url&quot;</span> <span class="attr">content</span>=<span class="string">&quot;https://ogp.me/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image&quot;</span> <span class="attr">content</span>=<span class="string">&quot;https://ogp.me/logo.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;image/png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:width&quot;</span> <span class="attr">content</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:height&quot;</span> <span class="attr">content</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:alt&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The Open Graph logo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The Open Graph protocol enables any web page to become a rich object in a social graph.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Open Graph 的官方文件由此去：<a href="https://ogp.me/">https://ogp.me/</a></p></blockquote><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以上就是這次對 metadata、<code>&lt;meta&gt;</code> 的小小研究，透過這次的撰寫，得到的收穫大概是：對 metadata 和 <code>&lt;meta&gt;</code> 有更詳細的了解。同時也可以理解 metadata 當中對 SEO 有幫助的部分，例如：整合標準網址、將 <code>&lt;meta&gt;</code> 的 description 寫的詳細一點等等。</p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://html.com/document/metadata/">What Is Metadata In HTML Documents?: Head Elements Explained</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10237545">What is metadata? - iT邦幫忙</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML">What’s in the head? Metadata in HTML - mozilla</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">meta: The metadata element - mozilla</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想要研究的主題是，網頁前端世界裡的三本柱 ── &lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt;、&lt;code&gt;JavaScript&lt;/code&gt; 之中的 &lt;code&gt;HTML&lt;/code&gt;。雖然 &lt;code&gt;HTML&lt;/code&gt; 並非如同 &lt;code&gt;JavaScript&lt;/code&gt; 有很多程式語言相關的主題與議題能夠探討，但是也是有一些有趣的主題值得研究和探索。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://simonecheng.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>【React】什麼是 Pure Function？在 React 當中的重要性是什麼？</title>
    <link href="https://simonecheng.github.io/react-pure-function/"/>
    <id>https://simonecheng.github.io/react-pure-function/</id>
    <published>2022-01-19T09:36:23.000Z</published>
    <updated>2023-07-15T13:26:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>在 functional programming 當中，有一個重要的概念稱為 pure function，而這個概念在 React 的官方文件當中被提起，那麼 pure function 在 React 當中到底扮演了什麼樣的角色呢？這是本文試圖理解並回答的問題。</p><span id="more"></span><p>目前的文章架構如下：</p><ul><li>什麼是 pure function？  </li><li>為什麼我們需要 pure function？</li><li>為什麼 pure function 在 React 裡面是重要的？</li></ul><p>在閱讀本文之前，你可能要有的先備知識：</p><ul><li>了解 React hooks 如何運作</li><li>了解 React functional components 裡面的 life cycle</li><li>了解一點點 Redux</li><li>最重要的是：了解 JavaScript</li></ul><h2 id="什麼是-pure-function？"><a href="#什麼是-pure-function？" class="headerlink" title="什麼是 pure function？"></a>什麼是 pure function？</h2><blockquote><p>A pure function is a function which:</p><ul><li>The function always returns the same result if the same arguments are passed in. It does not depend on any state, or data, change during a program’s execution. It must only depend on its input arguments.</li><li>The function does not produce any observable side effects such as network requests, input and output devices, or data mutation.</li></ul></blockquote><p>簡單來說，一個 function 只要符合以下兩個條件：</p><ol><li>相同的 input，永遠都輸出相同的 output。</li><li>沒有產生 side effect。跟其他function不會互相干擾，不會修改&#x2F;引用&#x2F;存取或是依賴到到外部變數，但是當作參數傳入是可以的。</li></ol><p>我們就可以把這個 function 稱為 pure function。但要怎麼樣才能符合這兩個條件餒？接下來可以來細看這兩個條件的意涵。</p><h3 id="條件一：相同的-input，永遠都輸出相同的-output"><a href="#條件一：相同的-input，永遠都輸出相同的-output" class="headerlink" title="條件一：相同的 input，永遠都輸出相同的 output"></a>條件一：相同的 input，永遠都輸出相同的 output</h3><h4 id="❌-不符合條件一的例子"><a href="#❌-不符合條件一的例子" class="headerlink" title="❌ 不符合條件一的例子"></a>❌ 不符合條件一的例子</h4><p>以下兩個 function 每次的 output 都不一樣，所以不符合條件一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">now</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br></pre></td></tr></table></figure><h4 id="✔️-符合條件一的例子"><a href="#✔️-符合條件一的例子" class="headerlink" title="✔️ 符合條件一的例子"></a>✔️ 符合條件一的例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b都是整數</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; input 是 1, 2，永遠都 return 3</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// =&gt; input 是 3, 5，永遠都 return 8</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// =&gt; input 是 4, 6，永遠都 return 10</span></span><br></pre></td></tr></table></figure><h3 id="條件二：沒有產生-side-effect"><a href="#條件二：沒有產生-side-effect" class="headerlink" title="條件二：沒有產生 side effect"></a>條件二：沒有產生 side effect</h3><h4 id="什麼是-side-effect？"><a href="#什麼是-side-effect？" class="headerlink" title="什麼是 side effect？"></a>什麼是 side effect？</h4><blockquote><p>An observable side effect is any interaction with the outside world from within a function. That could be anything from changing a variable that exists outside the function, to calling another method from within a function.</p><p>Note: If a pure function calls a pure function this isn’t a side effect and the calling function is still pure.</p></blockquote><p>簡單來說，side effect 指的就是在執行某個 function 時，該 function 的作用會影響到外面（比如全域環境或是其他 function 裡的東西），那麼「會影響到該 function 外面」這個行為，就叫做 side effect。</p><p>雖然 side effect 聽起來很像是負面的名詞，但不表示 side effect 就是不好的，在程式當中，side effect 單純就只是描述在寫 function 時有可能會出現的情況或是現象而已。</p><h4 id="side-effect-有哪些？"><a href="#side-effect-有哪些？" class="headerlink" title="side effect 有哪些？"></a>side effect 有哪些？</h4><p>以下介紹一些常見的 side effect，但不限於此：</p><ol><li>Making a HTTP request</li><li>Mutating data</li><li>Printing to a screen or console</li><li>DOM Query&#x2F;Manipulation</li><li>Math.random()</li><li>Getting the current time</li></ol><p>接下來直接以程式碼來舉例有 side effect 的 function 長什麼樣子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">impureAssoc</span>(<span class="params">key, value, object</span>) &#123;</span><br><span class="line">  object[key] = value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bobo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">impureAssoc</span>(<span class="string">&#x27;shoeSize&#x27;</span>, <span class="number">400</span>, person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br></pre></td></tr></table></figure><p>在上述的程式碼當中，當把 <code>person</code> 傳入 <code>impureAssoc</code> 這個 fucntion 裡面之後，<code>person</code> 從 <code>&#123; name: &#39;Bobo&#39; &#125;</code> 變成 <code>&#123; name: &#39;Bobo&#39;, shoeSize: 400 &#125;</code>。也就是說，透過 <code>impureAssoc</code> 這個 function，改變了全域變數 <code>person</code>，這也意味著這個 function 有 side effect。</p><p>我們把程式碼稍微改一下，在原本的 function 中先將傳入的 object 複製出一份一模一樣的，然後針對複製出來的那份進行修改，就可以消除這個 function 的 side effect：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pureAssoc</span> = (<span class="params">key, value, object</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newObject = &#123; ...object &#125;;</span><br><span class="line">  newObject[key] = value;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bobo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">pureAssoc</span>(<span class="string">&#x27;shoeSize&#x27;</span>, <span class="number">400</span>, person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Bobo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br></pre></td></tr></table></figure><p>如此一來，我們在沒有改動到原本的 <code>person</code> 的情況下，得到我們想要的 <code>result</code>。於是這個原本不 pure 的 function，也變 pure 了。</p><div class="warning">⚠️ <b>淺拷貝 v.s.深拷貝</b><br>你的複製真的是成功的複製嗎？有沒有可能你其實沒有複製到，所以還是會改動到原本的 data？  </div><h2 id="為什麼我們需要-pure-function？"><a href="#為什麼我們需要-pure-function？" class="headerlink" title="為什麼我們需要 pure function？"></a>為什麼我們需要 pure function？</h2><p>大概了解 pure function 的定義和什麼是 pure function 之後，就要來問：所以為什麼需要 pure function？它是用來幹嘛的？</p><p><strong>1.immediately testable, maintain and refactor easier</strong></p><p>「相同的 input，永遠都輸出相同的 output。」這個 pure function 的特性使它能夠非常容易地被拿來測試。</p><p>當你寫的程式越來越龐大，程式碼的閱讀性與語法簡潔、易於測試、維護與除錯、易於規模化等等，都會變成要考量的重點，這時 pure function 的好處就會非常明顯──好讀、好維護、data的改動可以被追蹤、比較不會出現一些預期之外的錯誤（side effect）。</p><p><strong>2.是 functional programming 很重要的 basic concept。</strong></p><h2 id="為什麼-pure-function-在-React-裡面是重要的？"><a href="#為什麼-pure-function-在-React-裡面是重要的？" class="headerlink" title="為什麼 pure function 在 React 裡面是重要的？"></a>為什麼 pure function 在 React 裡面是重要的？</h2><p>在 React 的官方文件 <a href="https://reactjs.org/docs/components-and-props.html">Components and Props</a> 中，特別提到了一句話：</p><blockquote><p>All React components must act like <strong>pure functions</strong> with respect to their props.</p></blockquote><p><img src="https://i.imgur.com/FtP80vu.png"></p><p>pure function 在 React 當中之所以重要，是因為：</p><ol><li>functional component：關係到 <code>useState()</code> 會不會將傳入的 state 視為不同的資料，然後重新 render。範例：<a href="https://codesandbox.io/s/case-1-wd1dh?file=/src/App.js">https://codesandbox.io/s/case-1-wd1dh?file=/src/App.js</a></li><li>確保不管在任何情況之下，傳入相同的 input，都會渲染出相同的畫面給使用者看（output）。</li><li>redux：和 <code>useState()</code> 也是同樣的道理，所以 reducers 也規定必須是 pure function。</li><li>還沒有 hooks 時，在 functional component 裡面，讓 props 只能是唯讀的，使資料在修改的時候比較好追蹤和管理。</li><li>A React component should be pure, this means the result of its render method should depend solely on the props and the state, and for the same properties and state render should give the same result. If render is not pure, it means it can return different results for the same input, so React cannot tell which parts of the DOM need to be updated based on the changes to the component. This is critical as the performance of React depends of this.</li></ol><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/">What Is a Pure Function in JavaScript? - FreeCodeCamp</a></li><li><a href="https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c">JavaScript: What Are Pure Functions And Why Use Them? - Medium</a></li><li><a href="https://dev.to/keevcodes/pure-functions-in-react-2o7n">Pure Functions in React - DEV</a></li><li><a href="https://blog.logrocket.com/react-pure-components-functional/">Pure functional components in React - LogRocket</a></li><li><a href="https://betterprogramming.pub/react-class-vs-functional-components-2327c7324bdd">React Class vs. Functional Components - Medium</a></li><li><a href="https://stackoverflow.com/questions/41985547/why-reactjs-components-must-act-like-pure-functions">Why ReactJS components must act like pure functions?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 functional programming 當中，有一個重要的概念稱為 pure function，而這個概念在 React 的官方文件當中被提起，那麼 pure function 在 React 當中到底扮演了什麼樣的角色呢？這是本文試圖理解並回答的問題。&lt;/p&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://simonecheng.github.io/tags/React/"/>
    
    <category term="funcitonal programming" scheme="https://simonecheng.github.io/tags/funcitonal-programming/"/>
    
  </entry>
  
</feed>
