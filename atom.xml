<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寫字練習</title>
  
  
  <link href="https://simonecheng.github.io/atom.xml" rel="self"/>
  
  <link href="https://simonecheng.github.io/"/>
  <updated>2022-05-15T10:41:50.940Z</updated>
  <id>https://simonecheng.github.io/</id>
  
  <author>
    <name>Simone Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【克服JS的奇怪部分】Types and Operators</title>
    <link href="https://simonecheng.github.io/JS-weird-parts-2/"/>
    <id>https://simonecheng.github.io/JS-weird-parts-2/</id>
    <published>2022-03-15T07:28:52.000Z</published>
    <updated>2022-05-15T10:41:50.940Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。</p><span id="more"></span><h2 id="Concept-Asides-名詞解釋"><a href="#Concept-Asides-名詞解釋" class="headerlink" title="Concept Asides 名詞解釋"></a>Concept Asides 名詞解釋</h2><h4 id="Dynamic-Typing-動態型別"><a href="#Dynamic-Typing-動態型別" class="headerlink" title="Dynamic Typing 動態型別"></a>Dynamic Typing 動態型別</h4><blockquote><p>You don’t tell the engine what type of data a variable holds, it figures it out while your code is running.<br>Variables can hold different types of values because it’s all figured out during execution.</p></blockquote><p>什麼是動態型別？</p><p>有很多程式語言是屬於強型別的語言，當使用強行別的語言時，在宣告變數的時候，同時也需要宣告這個變數的型別。但 JavaScript 不需要在宣告一個變數時，同時宣告該變數的型別， JavaScript Engine 會自己去判斷變數的型別。所以，JavaScript 是一種動態型別的語言。</p><h4 id="Primitive-Type-原始型別"><a href="#Primitive-Type-原始型別" class="headerlink" title="Primitive Type 原始型別"></a>Primitive Type 原始型別</h4><blockquote><p>A type of data that represents a single value.</p></blockquote><p>JavaScript 總共有六種原始型別，分別是：string、boolean、number、undefined、null、symbol。</p><h4 id="Operator-運算子"><a href="#Operator-運算子" class="headerlink" title="Operator 運算子"></a>Operator 運算子</h4><blockquote><p>A special function that is syntactically (written) differently.<br>Generally, operators take two parameters and return one result.</p></blockquote><p>當打出以下的程式碼時，我們會很直覺地認為會印出 7，但那是從人類的角度出發去做加減法，至於在 JavaScript Engine 當中是如何執行這段程式碼的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure><p>其實對 JavaScript Engine 來說，他在背後做的事情比較像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> +(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// add the two variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三種不同的運算子表示方式 //</span></span><br><span class="line">+<span class="number">3</span> <span class="number">4</span> <span class="comment">// prefix notation</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> <span class="comment">// infix notation</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span>+ <span class="comment">// postfix notation</span></span><br></pre></td></tr></table></figure><p><code>+</code> 其實是一個 JavaScript 裡面本來就有的 function，所以當我們寫了 <code>+</code> 時，就是呼叫這個 function ，然後將兩個變數傳進去做加法，然後回傳出一個新的值。只是這個 function 是寫在兩個變數中間，也就是 <code>3 + 4</code>，這樣將運算子寫在中間的表示方式稱為 infix notation。</p><p>總之，在 JavaScript 中，運算子其實是一種 function，傳入兩個值，然後會回傳一個值。</p><h4 id="Coercion-強制轉型"><a href="#Coercion-強制轉型" class="headerlink" title="Coercion 強制轉型"></a>Coercion 強制轉型</h4><blockquote><p>Converting a value from one type to another.<br>This happens quite often in JavaScript because it’s dynamically typed.</p></blockquote><p>因為 JavaScript 是動態型別的語言，所以在程式執行的時候，它時不時會將寫好的變數或是值自動轉換型別，來看看以下簡易的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;Hello &#x27;</span> + <span class="string">&#x27;World&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure><p>在上述例子當中， a 和 b 都是同型別相加，所以我們可以知道 a 會印出 3，b 會印出 Hello World。但如果是不同型別之間的相加呢？比如以下的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">1</span> + <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><p>在這個範例中，和其他程式語言不同，JavaScript 不會因為這兩個值的型別不同而報錯，反而會嘗試將這兩個值轉成相同的型別，所以此時數字 1 會被轉型成字串 1，然後再與字串 2 相加，最後會印出字串 12。這個現象就是 Coercison。理解在 JavaScript 中有這個現象後，更容易在撰寫程式的時候避免許多因為轉型造成的錯誤。</p><div class="info">💡 <b>目前學到的轉型規則</b> 💡<br>當有兩個東西「相加」的時候，如果其中一個東西是字串，JavaScript 會嘗試將另一個東西也轉成字串。</div><h2 id="Operator-Precedence-and-Associativity"><a href="#Operator-Precedence-and-Associativity" class="headerlink" title="Operator Precedence and Associativity"></a>Operator Precedence and Associativity</h2><p>首先要來定義什麼是 Operator Precedence 和 Associativity：</p><blockquote><p><b>Operator Precedence:</b> which operator get called first.<br>Functions are called in order of precedence. (Higher precedence wins.)</p></blockquote><blockquote><p><b>Associativity:</b> what order operator functions get called in: left-to-right or right-to-left, when functions have the same precedence.</p></blockquote><p>簡單來說，當有多個運算子出現在一個運算式當中的時候，需要透過 Precedence 來決定要先執行哪個運算，如果每個運算子的優先順序都相同的話，再透過 Associativity 去決定是要從左到右或是從右到左執行優先級相同的運算子。</p><p>先來看看一個只需要用到 Precedence 的簡單範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span> * <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>在上述的程式碼當中，因為 <code>*</code> 的優先級比 <code>+</code> 高，所以 JavaScript Engine 會先做 <code>*</code> 再做 <code>+</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先做 *</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再做 +</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最後印出</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>JavaScript Engine 就是如上在執行運算子的運算，先將兩個值丟進一個運算的 function，然後回傳出一個新的值，再繼續做下一個運算子的運算，但也是因為這樣的運作方式，還有 JavaScript 本身是動態型別語言的關係，會導致一些奇怪的現象。</p><p>但在觀察這些奇怪的現象之前，先繼續來看看 Operator Precedence 和 Associativity 合在一起的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">a = b = c;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><p>在上述的例子當中，可以看到 <code>a = b = c</code> 這一行的運算子優先級是相同的（因為都是 &#x3D;，每個 &#x3D; 的優先級相同），接下來要看的就是 &#x3D; 的 Associativity，到 MDN 文件查之後，知道 &#x3D; 的 Associativity 是從右到左，所以 <code>a = b = c</code> 會從右到左執行，先執行 <code>b = c</code> 再執行 <code>a = b</code>，也就是說會先將 c 賦值給 b，再將 b 賦值給 c，所以最後 a、b、c 都會印出 4。</p><p>從以上兩個例子中，可以很清楚的知道 Operator Precedence 和 Associativity 的作用。</p><h2 id="Comparison-Operators"><a href="#Comparison-Operators" class="headerlink" title="Comparison Operators"></a>Comparison Operators</h2><p>在這個小節當中，講師提到當所有以上概念（Coercion、Operator Precedence and Associativity）合在一起的時候，JavaScript 會出現一些讓人困惑的現象。</p><p>第一個讓人困惑的地方是，JavaScript 在計算多個運算子的時候，運算的方式其實與人腦的運算方式並不同，所以會出現一些我們預期之外的狀況。</p><p>首先先觀察一個符合人們直覺的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上述的程式碼會印出 true，而這個也符合人們對數學運算的理解，1 的確是小於2，2 也的確是小於 3。但如果是以下的程式碼呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> &lt; <span class="number">2</span> &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>JavaScript 還是會印出 true，這時候就要來理解，當看到 3 &lt; 2 &lt; 1 的時候，JavaScript Engine 是以下面的步驟在運作的：</p><ol><li>根據 Operator Associativity 先執行 3 &lt; 2，得到 false</li><li>進行 false &lt; 1 的運算</li><li>嘗試把 false 轉型成 number，所以 false &lt; 1 變成 0 &lt; 1</li><li>進行 0 &lt; 1 的運算</li><li>得到 true，然後印出來</li></ol><p>從以上步驟可以知道，JavaScript Engine 在進行各種運算子運算的時候，與我們平常在算數學時使用的計算方式不同。</p><hr><p>第二個讓人困惑的地方是有關 undefined、false、null 這三個型別如果被轉型成數字的話，我們會預期都是 0。但實際上並不是，undefined 會被轉型成 NaN，false、null 才會被轉型成數字 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><p>第三個讓人困惑的地方是，如果使用運算子，特別是 <code>==</code> 的時候（因為使用兩個等於會先轉型才比較），又會發生讓人困惑的狀況，比如以下幾個例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> &lt; <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由於使用 <code>==</code> 會導致互相比較的值先轉型才進行比較，但我們很多時候並沒有辦法準確預測 JavaScript Engine 會將值轉型成什麼型別，可能會造成小錯誤。</p><p>在 JavaScript 當中，還有另外一個運算子 <code>===</code> 也可以用來比較兩個值是否相等。使用 <code>===</code> 時並不會使想要比較的值被轉型，會先比較型別是否相同然後才比較兩者的值，如果型別不同便會直接回傳 false，所以可以盡量使用 <code>===</code> 會比較好。</p><h2 id="什麼時候用到了-Coercion？"><a href="#什麼時候用到了-Coercion？" class="headerlink" title="什麼時候用到了 Coercion？"></a>什麼時候用到了 Coercion？</h2><p>其實平常在寫 code 的時候，我們也默默用到了很多轉型的概念，比如說以下的 react 的使用情境就是利用當 state 是空字串時會轉型成 false，非空字串會轉型成 true ，來判斷要顯示什麼樣的畫面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="title class_">Component</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setState</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">    &#125;, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="comment">// 這邊的 state ? 就用到了轉型 //</span></span><br><span class="line">        &#123;state ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;state&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>There is no state<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN 文件 - Operator precedence</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">MDN 文件 - Equality comparisons and sameness</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://simonecheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【克服JS的奇怪部分】Execution Contexts &amp; Lexical Environments</title>
    <link href="https://simonecheng.github.io/JS-weird-parts-1/"/>
    <id>https://simonecheng.github.io/JS-weird-parts-1/</id>
    <published>2022-03-11T10:11:05.000Z</published>
    <updated>2022-05-15T10:41:50.940Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。</p><span id="more"></span><h2 id="Concept-Asides-名詞解釋"><a href="#Concept-Asides-名詞解釋" class="headerlink" title="Concept Asides 名詞解釋"></a>Concept Asides 名詞解釋</h2><h4 id="Syntax-Parser-語意分析"><a href="#Syntax-Parser-語意分析" class="headerlink" title="Syntax Parser 語意分析"></a>Syntax Parser 語意分析</h4><blockquote><p> A program that reads your code and determines what it does and if its grammar is valid.</p></blockquote><p>當我們在寫 JavaScript 的時候，寫完之後其實電腦是看不懂的，而是需要透過編譯器(complier) 來翻譯成電腦看得懂的語言，才能夠幫我們執行我們想要實現的功能。</p><p><img src="/../assets/complie-flowchart.png"></p><h4 id="Lexical-Environment-詞彙環境"><a href="#Lexical-Environment-詞彙環境" class="headerlink" title="Lexical Environment 詞彙環境"></a>Lexical Environment 詞彙環境</h4><blockquote><p> Where something sits physically in the code you write.</p></blockquote><p>當我們在寫 JavaScript 的時候，Lexical Environment 關注的是這個 function 被寫在這個程式中的哪個部分，以及它周遭的環境是什麼，有了 Lexical Environment，可以讓 Syntax Parser 更容易解析整個程式碼，比如說以下的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a  = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 這個變數是存在於 Greeting 這個函數的環境中</span></span><br></pre></td></tr></table></figure><p>並不是所有的程式語言都有 Lexical Environment，但 JavaScript 有。</p><h4 id="Execution-Context-執行環境"><a href="#Execution-Context-執行環境" class="headerlink" title="Execution Context 執行環境"></a>Execution Context 執行環境</h4><blockquote><p>A wrapper to help manage the code that is running.<br>There are lots of lexical environments. Which one is currently running is managed via execution contexts. It can contain things beyond what you’ve written in your code.</p></blockquote><p>當我們寫好程式碼之後，我們該如何知道它是按照什麼樣的順序被電腦執行的？整個程式碼的執行流程是如何安排的？這就是 Execution Context 需要做的工作。</p><h4 id="Name-x2F-Value-Pair"><a href="#Name-x2F-Value-Pair" class="headerlink" title="Name&#x2F;Value Pair"></a>Name&#x2F;Value Pair</h4><blockquote><p>A name which maps to a unique value.<br>The name may be defined more than once, but only can have one value in any given <strong>context</strong>.<br>That value may be more name&#x2F;value pairs.</p></blockquote><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><blockquote><p>A collection of name&#x2F;value pairs.<br>The simplest definition when talking about <strong>JavaScript</strong>.</p></blockquote><h4 id="JavaScript-and-‘undefined’"><a href="#JavaScript-and-‘undefined’" class="headerlink" title="JavaScript and ‘undefined’"></a>JavaScript and ‘undefined’</h4><p>直接來看看兩個不同的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 印出 undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 報錯：印出 Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>我們可以知道範例一和範例二都印出了東西，但 undefined 和 is not defined 從英文字面上來看不是一樣的意思嗎？其實這兩者對 JavaScript 來說是兩個不一樣的東西。</p><p><strong>undefined</strong> 在這裡的意思是：JavaScript 已經為這個變數預留了一個記憶體的位置，但因為這個變數還沒有被賦值，所以 JavaScript 就先暫時設了一個初始值給你，然後這個初始值叫做「undefined」。所以我們可以把 undefined 理解為「尚未設定的值」。</p><p><strong>is not defined</strong> 的意思則是：JaveScript 在記憶體位置當中並沒有尋找到該變數，所以它就會報錯，告訴我們 <code>Uncaught ReferenceError: a is not defined</code>。</p><h4 id="Single-Threaded-單執行緒"><a href="#Single-Threaded-單執行緒" class="headerlink" title="Single Threaded 單執行緒"></a>Single Threaded 單執行緒</h4><blockquote><p>One command at a time.<br>Under the hood of the browser, maybe not.</p></blockquote><p>JavaScript 是一個單執行緒的語言，也就是說 JavaScript 在執行的時候，一次只能做一件事情。但是如果我們是在 browser 這個環境之下執行 JavaScript，browser 本身可以幫我做到多執行緒的事情，但是就像開頭提到的 JavaScript 本身是一個單執行緒的語言。</p><h4 id="Synchrnous-Execution-同步執行"><a href="#Synchrnous-Execution-同步執行" class="headerlink" title="Synchrnous Execution 同步執行"></a>Synchrnous Execution 同步執行</h4><blockquote><p>One at a time and in order.</p></blockquote><p>JavaScript 是同步執行的，也就是說做完一件事情，才會做下一件事情，而且會按照事情排好的順序依序做下去。</p><h2 id="The-Global-Environment-and-The-Global-Object"><a href="#The-Global-Environment-and-The-Global-Object" class="headerlink" title="The Global Environment and The Global Object"></a>The Global Environment and The Global Object</h2><p>當 JavaScript 在執行的時候，它一定會在一個全域執行環境 (Global Environment) 當中執行，在這個環境當中會有一個全域物件 (Global Object)，以及一個很特殊的 variable 「this」。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────┐</span><br><span class="line">│ Execution Context(Global)                                 │</span><br><span class="line">│      ┌──────────────────┐     ┌───────────────────┐       │</span><br><span class="line">│      │                  │     │                   │       │</span><br><span class="line">│      │   Global Object  │     │        this       │       │</span><br><span class="line">│      │                  │     │                   │       │</span><br><span class="line">│      └──────────────────┘     └───────────────────┘       │</span><br><span class="line">└───────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>當我們在瀏覽器中執行 JavaScript 時，瀏覽器是一個 runtime，所以此時 JavaScript 所在的 Global Execution Context，就是瀏覽器的全域環境，在這個環境裡有一個 Global Object 叫做「window」。當我們在這個全域環境當中直接打 <code>console.log(this);</code> 的時候，<code>this</code> 指的就是 <code>window</code>。至於當我們在 node.js 當中執行 JavaScript 時，此時的 Global Object 和 this 就會是 node.js 設定好的。</p><p>假設目前在瀏覽器中使用 <code>var</code> 宣告一個變數 a ，而且這個變數 a 等於 1 時，其實就是在瀏覽器當中的 Global Object 中建立一個 Name&#x2F;Value Pair，所以可以透過 <code>window.a</code> 這個指令來找到剛才宣告的變數 a。如以下程式碼所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><div class="info">es6 新增了兩個新的宣告方式 <code>const</code> 以及 <code>let</code>，這兩個的用法與 <code>var</code> 不同，如果在全域環境使用 <code>const</code> 或 <code>let</code>，並不會在 Global Object 中建立一個 Name/Value Pair，避免了一些使用 <code>var</code> 會產生的問題。這三者的比較可能會之後再寫一篇筆記做更深入探討。</div><h2 id="The-Execution-Context"><a href="#The-Execution-Context" class="headerlink" title="The Execution Context"></a>The Execution Context</h2><h4 id="Creation-and-Hoisting"><a href="#Creation-and-Hoisting" class="headerlink" title="Creation and Hoisting"></a>Creation and Hoisting</h4><p>在開始說明 JavaScript Engine 如何創建執行環境時，我們先來看看 JavaScript 的特殊現象「Hoisting」。首先來看看以下範例一的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>將上述的程式碼執行之後，我們可以很輕鬆也如常的預期會先印出 <code>Called b!</code>，再印出　<code>Hello World!</code>，但如果我們把程式碼改成下面這樣呢？</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程式碼是從上到下，一行一行依序執行的話，照理來說在跑第一行的時候就會報錯，因為我們在尚未宣告變數和函數時，就對該變數或函數進行呼叫。但在 JavaScript 裡面卻不是這樣，將以上程式碼執行之後，JavaScript會幫我們印出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Called</span> b!</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>JavaScript 並沒有幫我們報錯，反而印出東西來，這是因為在這當中存在著「Hoisting」的現象。很多網路上對「Hoisting」的解釋大部分都是：想像 JavaScript Engine 將所寫的宣告的程式碼（但如果是宣告變數的話，只會提升宣告的變數，不會連同賦值的部分一起提升）提升到最上面的地方，比如想像範例二的程式碼變成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以我們才會得到印出 <code>Called b!</code> 和 <code>undefined</code> 的結果。但其實 JavaScript Engine 並不會真的去調動你所寫的程式碼的位置，所以「<strong>想像 JavaScript Engine 將所寫的宣告的程式碼（但如果是宣告變數的話，只會提升宣告的變數，不會連同賦值的部分一起提升）提升到最上面的地方</strong>」這樣的描述雖然能夠解釋 Hoisting 這個現象，但它並沒有精確地去描述 JavaScript Engine 在 Hoisting 的時候實際上到底做了什麼。</p><p>所以 JavaScript Engine 到底做了什麼？在 Execution Context 被創建之後，除了同時創建了 Global Obeject、this 之外，還會同時先預留記憶體位置給變數與函式。</p><p>這個「<strong>先預留記憶體位置給變數與函式</strong>」的動作就是 Hoisting。但要特別注意的地方是：當宣告的 function 被 hoisted 的時候，除了 funciton 的名稱會被 hoisted，整個 funciton 裡面的 code 也會被 hoisted。但如果是使用 <code>var</code> 來宣告變數的時候，只有變數的名稱會被 hoisted，賦值這個動作並不會被 hoisted，然後 JavaScript Engine 會將所有被 hoisted variable 的初始值設為 undefined。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                                    │</span><br><span class="line">│  Execution Context is Created (Creation Phase)                                     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌────────────────────┐    ┌───────────────────┐      ┌──────────────────┐     │</span><br><span class="line">│      │      Global        │    │                   │      │      Outer       │     │</span><br><span class="line">│      │                    │    │      &#x27;this&#x27;       │      │                  │     │</span><br><span class="line">│      │      Object        │    │                   │      │   Environment    │     │</span><br><span class="line">│      └────────────────────┘    └───────────────────┘      └──────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌───────────────────────────────────────────────────────────────────────┐     │</span><br><span class="line">│      │      Set up Memory Space for Variables and Functions                  │     │</span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      │            &quot;Hoisting&quot;                                                 │     │</span><br><span class="line">│      └───────────────────────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><div class="warning">盡量在執行函數或使用變數之前先宣告他們，不要過度依賴於 Hoisting 的現象。因為你不知道你宣告的變數有沒有可能會變成 undefined。</div><h4 id="Code-Execution"><a href="#Code-Execution" class="headerlink" title="Code Execution"></a>Code Execution</h4><p>JavaScript 在執行程式碼的時候就比較好理解了，不會有什麼 Hoisting 啦之類的奇怪的事情發生，就是我們寫好的程式碼會被 JavaScript Engine 在它該在的環境當中被一行一行的執行。但要特別注意的是，JavaScript 是單執行緒的語言喔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                                    │</span><br><span class="line">│  Execution Context is Created (Execution Phase)                                    │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌────────────────────┐    ┌───────────────────┐      ┌──────────────────┐     │</span><br><span class="line">│      │      Global        │    │                   │      │      Outer       │     │</span><br><span class="line">│      │                    │    │      &#x27;this&#x27;       │      │                  │     │</span><br><span class="line">│      │      Object        │    │                   │      │   Environment    │     │</span><br><span class="line">│      └────────────────────┘    └───────────────────┘      └──────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">│      ┌───────────────────────────────────────────────────────────────────────┐     │</span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      │                            Runs Your Code                             │     │  </span><br><span class="line">│      │                                                                       │     │</span><br><span class="line">│      └───────────────────────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                                    │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Function-Invocation-and-the-Execution-Stack-Call-Stack"><a href="#Function-Invocation-and-the-Execution-Stack-Call-Stack" class="headerlink" title="Function Invocation and the Execution Stack(Call Stack)"></a>Function Invocation and the Execution Stack(Call Stack)</h2><blockquote><p><strong>nvocation</strong>: running a function<br>In JavaScript, we can use parenthesis() to invocate function.</p></blockquote><p>當使用 JavaScript 呼叫函式的時候，底層做了什麼樣的事情？換句話說，函式被我們呼叫以後，JavaScript 是怎麼執行這些函式的？我們可以試著用以下的程式碼來舉例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>當我們開始執行以上的程式碼的時候，首先會先在 Execution Stack 裡面建立一個 Global Execution Context，接著當程式碼一行一行跑下來跑到 <code>a()</code> 然後執行 <code>a</code> 這個函式的時候，JavaScript 會為這個函數創建它的 Execution Context，並將它放到 Execution Stack（執行堆疊）當中，疊在 Global Execution Context 上面。</p><p>然後因為 <code>a()</code> 函式被執行了，連帶 <code>a()</code> 當中的 <code>b()</code> 也被執行，所以 JavaScript 也為 <code>b()</code> 函式創建了一個 Execution Context，而 <code>b()</code> 的 Execution Context 會疊在 <code>a()</code> 上面。</p><p>在 Execution Stack 當中函式的執行順序是由上往下執行的，也就是說，以此範例為例，會先執行 <code>b()</code>、在執行 <code>a()</code>，當 <code>b()</code> 執行完之後，<code>b()</code>就會離開執行堆疊（英文稱作 pop off），以此類推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                  .                  │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │ ────► Execution Stack</span><br><span class="line">│ │             b()                 │ │</span><br><span class="line">│ │      Execution Context          │ │</span><br><span class="line">│ │     (create and execute)        │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │</span><br><span class="line">│ │            a()                  │ │</span><br><span class="line">│ │      Execution Context          │ │</span><br><span class="line">│ │     (create and execute)        │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">│ ┌─────────────────────────────────┐ │</span><br><span class="line">│ │    Global Execution Context     │ │</span><br><span class="line">│ │  (created and code is executed) │ │</span><br><span class="line">│ └─────────────────────────────────┘ │</span><br><span class="line">│                                     │</span><br><span class="line">└─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Functions-Context-and-Variables-Environments"><a href="#Functions-Context-and-Variables-Environments" class="headerlink" title="Functions, Context, and Variables Environments"></a>Functions, Context, and Variables Environments</h2><blockquote><p><strong>Variable Environment</strong>: where the variables live and how they realte to each other in memory</p></blockquote><p>在每個 Execution Context 被創建之後，同時該 Execution Context 也會有一個自己的 Variable Environment。我們可以透過以下的程式碼為例，來說明 Variable Environment 在 JavaScript 中是如何被建立的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><p>當上述程式碼被執行之後，myVar 會是什麼值？程式碼執行後，JavaScript Engine 會分別在 Global、a()、b() 各自的 Execution Context 中各建立一個 Variable Environment，所以 myVar 在不同的 Execution Context 當中就會有不同的值，需要先觀察目前程式碼執行到哪邊，再去判斷 myVar 目前的值。如下圖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │  ───────► Execution Stack</span><br><span class="line">│   │                  b()                          │    │</span><br><span class="line">│   │                                               │    │</span><br><span class="line">│   │           Execution Context       ┌─────────┐ │    │</span><br><span class="line">│   │                                   │   myVar │ │    │</span><br><span class="line">│   │          (create and execute)     │undefined├─┼────┼──────┐</span><br><span class="line">│   └───────────────────────────────────┴─────────┴─┘    │      │</span><br><span class="line">│                                                        │      │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │      │</span><br><span class="line">│   │                  a()                          │    │      │</span><br><span class="line">│   │                                               │    │      │</span><br><span class="line">│   │           Execution Context         ┌───────┐ │    │      │</span><br><span class="line">│   │                                     │ myVar │ │    │      │</span><br><span class="line">│   │          (create and execute)       │   2   ├─┼────┼──────┼─────► Variable Environment</span><br><span class="line">│   └─────────────────────────────────────┴───────┴─┘    │      │</span><br><span class="line">│                                                        │      │</span><br><span class="line">│   ┌───────────────────────────────────────────────┐    │      │</span><br><span class="line">│   │                                               │    │      │</span><br><span class="line">│   │      Global Execution Context                 │    │      │</span><br><span class="line">│   │                                     ┌───────┐ │    │      │</span><br><span class="line">│   │    (created and code is executed)   │ myVar │ │    │      │</span><br><span class="line">│   │                                     │   1   ├─┼────┼──────┘</span><br><span class="line">│   └─────────────────────────────────────┴───────┴─┘    │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="The-Scope-Chain"><a href="#The-Scope-Chain" class="headerlink" title="The Scope Chain"></a>The Scope Chain</h2><p>還記得我們在前面提到，程式碼執行之後，會為每個執行的函數建立自己的 Execution Context、自己的 Variable Environment。現在我們要談到，當程式碼執行後除了會建立上述提到的部分，還會建立一個 Outer Environment，意思就是指會建立一個對外的 Scope 參照。</p><p>總結來說，當一個 Execution Context 被建立的時候，裡面會有以下幾種東西：</p><ul><li>Global Object</li><li>this</li><li>Hoisting</li><li>Outer Environment</li><li>Variable Environment</li></ul><p>所以，建立一個對外的 Scope 參照是什麼意思？</p><p>如果用文字敘述來說明的話，指的是 JavaScript Engine 會去檢查該程式碼（比如說某個 function）的 Lexical Environment，也就是去檢查某個 funciton 的所在位置，再將該 function 所在位置的 variable environment 當作參照。</p><p>比如某個 function 是在全域環境中宣告的，那麼當 JavaScript Engine 在執行該 function 的時候，除了會建立 function 自己的 variable environment 之外，也會去參照這個 function 所在位置的 variable environment，也就是全域環境的 variable environment。</p><p>而上述提到的這種行為，便會導致一個稱為「Scope Chain」的現象發生。我們現在可以來看看以下幾個不同的程式碼，來更加了解 Scope Chain。</p><hr><p>首先來觀察狀況一，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在全域，於是 JavaScript Engine 又在全域環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現有，於是便印出 <code>1</code>。</p><hr><p>接下來來看看狀況二，在狀況二的程式碼中，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在 <code>a function</code> 裡面宣告的，於是 JavaScript Engine 又在 <code>a function</code> 的執行環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現有，於是便印出 <code>２</code>。</p><hr><p>接下來來看看狀況三，在狀況三的程式碼中，<code>b()</code> 裡面的 <code>console.log(myVar)</code> 會印出什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狀況三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(myVar);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><p>因為 <code>b()</code> 裡面並沒有宣告 <code>myVar</code> 這個變數，所以 JavaScript Engine 會藉由 Lexical Context 去檢查 <code>function b</code> 在哪個環境被宣告的，檢查之後發現是在 <code>a function</code> 裡面宣告的，於是 JavaScript Engine 又在 <code>a function</code> 的執行環境中檢查是不是有 <code>myVar</code> 這個變數，然後發現沒有，於是又再繼續檢查 <code>a funciton</code> 是在哪個環境被宣告的，檢查之後發現是在全域環境，於是又再繼續檢查全域環境有沒有變數 <code>myVar</code>，然後終於發現有，於是便印出 <code>1</code>。</p><hr><p>從以上三個狀況中，可以看到以下幾個步驟：</p><ol><li>某個函式被呼叫並執行</li><li>JavaScript Engine 檢查該函式的 Lexical Context，確定它的 Outer Environment（也就是函式被宣告的環境）。</li><li>如果某個函式呼叫了一個自己的 Variable Environment 沒有的變數，JavaScript Engine 就會開始往 Outer Environment 的 Variable Environment 檢查有沒有那個變數。</li><li>一直重複步驟 3，直到找到那個變數，或是找到最後發現沒有那個變數</li></ol><p>這種不斷地往 Outer Environment 尋找 Variable 的現象就稱為「Scope Chain」。</p><h2 id="Scope-ES6-and-let"><a href="#Scope-ES6-and-let" class="headerlink" title="Scope, ES6, and let"></a>Scope, ES6, and let</h2><blockquote><p>Scope: where a variable is available in your code.</p></blockquote><p>在 ES6 以前，若想要宣告一個變數，只有 <code>var</code> 可以用，但在 ES6 公布之後，目前有 <code>var</code>、<code>const</code>、<code>let</code> 可以用來宣告變數。</p><p>這三者之間也有些許不同。用 <code>let</code> 和 <code>const</code> 宣告變數後，那個變數所在的 Scope 是一個 block Scope（例如用<code>&#123;&#125;</code>圍起來就是一個 block），而用 <code>var</code> 則會將變數宣告在 Function Scope 當中。</p><p>用 <code>var</code>、<code>const</code>、<code>let</code> 都會有 Hoisting 的現象，只是使用 <code>var</code> 時，會給予變數一個 undefined 的初始值，但如果是 <code>const</code>、<code>let</code> 的話，則是會讓變數存在暫時死區無法使用，然後報錯。</p><table><thead><tr><th></th><th><code>var</code></th><th><code>const</code></th><th><code>let</code></th></tr></thead><tbody><tr><td>作用域</td><td>函式作用域</td><td>區塊作用域</td><td>區塊作用域</td></tr><tr><td>Hoisting</td><td>undefined</td><td>進入暫時死區，會報錯</td><td>進入暫時死區，會報錯</td></tr></tbody></table><h2 id="What-about-Asynchronous-Callbacks"><a href="#What-about-Asynchronous-Callbacks" class="headerlink" title="What about Asynchronous Callbacks?"></a>What about Asynchronous Callbacks?</h2><p>在前面的影片有提到 JavaScript 是一個單執行緒、同步的語言（一次只做一件事情），但是在瀏覽器當中卻可以做到非同步（一次做很多件事情），這到底是如何辦到的？是因為有瀏覽器這個執行的環境，它可以先做一些非同步的處理，然後再將處理好的函數一一丟到 JavaScript Engine 當中去執行。</p><p>瀏覽器處理非同步的過程有個專有名詞稱為 Event Loop，也許之後可以再寫一篇筆記來記錄瀏覽器當中的 Event Loop 是如何運作的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇是記錄 Udemy 上面的課程 JavaScript: Understanding the Weird Parts 的筆記。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://simonecheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>metadata、meta 知多少</title>
    <link href="https://simonecheng.github.io/metadata/"/>
    <id>https://simonecheng.github.io/metadata/</id>
    <published>2022-01-29T09:55:38.000Z</published>
    <updated>2022-05-15T10:41:50.940Z</updated>
    
    <content type="html"><![CDATA[<p>今天想要研究的主題是，網頁前端世界裡的三本柱 ── <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code> 之中的 <code>HTML</code>。雖然 <code>HTML</code> 並非如同 <code>JavaScript</code> 有很多程式語言相關的主題與議題能夠探討，但是也是有一些有趣的主題值得研究和探索。</p><span id="more"></span><p>之前在寫 side project 或是技術面試被問到該如何優化 SEO 時，當時只有辦法大概回答出可以透過 <code>HTML</code> 當中的 metadata 去優化 SEO，但是並不清楚 metadata 實際上有哪些用法，或是可以做到哪些事情，所以這次想要試著以一種更詳細和全面的角度來理解 <code>HTML</code> 當中會使用到的 metadata 和 <code>&lt;meta&gt;</code> 這兩個東西。（當然有機會的話，之後也想要寫一個 SEO 的系列文來理解 SEO 和知道如何優化它）</p><p>本文架構如下：</p><ul><li><strong>metadata 是什麼？</strong> → 首先會先定義 metadata 是什麼</li><li><strong>metadata 有哪些？</strong> → 接著解釋 metadata 在 <code>HTML</code> 當中的應用</li><li><strong>淺談 <code>&lt;meta&gt;</code></strong> → 最後會對 <code>&lt;meta&gt;</code> 這個用法做更深入的研究</li></ul><p>你可能要有的先備知識：</p><ul><li>知道 <code>HTML</code> 是什麼</li><li>了解 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 的差別</li></ul><h2 id="metadata-是什麼？"><a href="#metadata-是什麼？" class="headerlink" title="metadata 是什麼？"></a>metadata 是什麼？</h2><p>首先可以先從現有的網路資源當中，去尋找 metadata 的定義。在 MDN 文件當中，解釋了什麼是 metadata：</p><blockquote><p><strong>Metadata</strong> is — in its very simplest definition — data that describes data. For example, an HTML document is data, but HTML can also contain metadata in its <code>&lt;head&gt;</code> element that describes the document — for example who wrote it, and its summary.</p></blockquote><p>直接翻譯的話，metadata 的意思就是「描述資料」的資料，這樣子聽起來可能還是一頭霧水，但如果我們以一個實際的例子來說明的話，可能會清楚許多。</p><p>假設現在有一個猜拳遊戲網頁的 <code>HTML</code> 檔，架構如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-Hant-TW&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- metadata, 使用者不會看到，但是會提供這個 HTML 檔相關的資訊，例如以下四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;猜拳遊戲&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rock_Paper_Scissors Game<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用者會看到的內容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常在 <code>&lt;body&gt;</code> 這個標籤中會放滿希望讓使用者看到的畫面；另外將描述這個網頁的資訊，比如這個網頁的作者、這個網頁的用途、這個網頁的編碼方式、要套用的 <code>css</code> 檔、要套用的 <code>JavaScript</code> 檔等等，放在 <code>&lt;head&gt;</code> 這個標籤當中。</p><p>這些放在 <code>&lt;head&gt;</code> 當中的資訊，並且用來描述這個 <code>HTML</code> 網頁檔是要用來做什麼、或是要運行什麼東西，都可以稱之為 metadata。通常這些 metadata 的資訊會被搜尋引擎的爬蟲爬取並解析，於是我們可以在這裡很簡單地暴力推測：如果 metadata 寫得越完整，對 SEO 的幫助越大，也可以說是優化 SEO 的方法之一。</p><h2 id="metadata-有哪些？"><a href="#metadata-有哪些？" class="headerlink" title="metadata 有哪些？"></a>metadata 有哪些？</h2><p>在上一個小節理解 metadata 的定義之後，那接下來的問題就是：實際上要如何在 <code>HTML</code> 當中寫出 metadata 呢？這也是本小節試圖回答和整理的問題。</p><h3 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h3><p>在每個 <code>HTML</code> 檔的 <code>&lt;head&gt;</code> 當中，基本上一定都會有 <code>&lt;title&gt;</code> 這個標籤（tag），它的語法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert Title Here | Follow it with the Website Name if you Wish<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>藉由 <code>title</code> 這個標籤，可以讓搜尋引擎知道這個網頁的名稱，並將它顯示在搜尋結果頁上面。或是也可以在瀏覽器的頁籤上看到 <code>&lt;title&gt;</code> 的內容，讓使用者知道自己目前在哪個網頁，比如說進到臉書首頁時，在瀏覽器頁籤上看到 Facebook 字樣，是因為 <code>&lt;title&gt;Facebook&lt;/title&gt;</code> 的緣故。 </p><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h3><p><code>&lt;link&gt;</code> 這個標籤的用途蠻多元的，目前我自己最常用到的是將 <code>CSS</code> 檔引入到 <code>HTML</code> 當中，讓網頁上的元素可以套用樣式，除此之外還有一些其他的用途，例如：加入網頁的 Logo、用標準網址（Canonical URL）整合重複性的網址等等。</p><h4 id="將-CSS-檔引入（Load-Stylesheets）"><a href="#將-CSS-檔引入（Load-Stylesheets）" class="headerlink" title="將 CSS 檔引入（Load Stylesheets）"></a>將 <code>CSS</code> 檔引入（Load Stylesheets）</h4><p>平常在撰寫網頁時，除了需要 <code>HTML</code> 來建立網頁的架構，也會需要 <code>CSS</code> 來讓網頁上的內容套用美美的樣式，通常會將 <code>CSS</code> 樣式寫在另外一個檔案裡，再引入到 <code>HTML</code> 當中，可以使用以下語法來引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;[fileName].css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="加入網頁-Logo（Add-a-Favicon）"><a href="#加入網頁-Logo（Add-a-Favicon）" class="headerlink" title="加入網頁 Logo（Add a Favicon）"></a>加入網頁 Logo（Add a Favicon）</h4><p>打開一個網頁時，頁籤上除了會顯示 <code>&lt;title&gt;</code> 中的網頁名稱之外，也會看到在網頁名稱前面有個小小的 Logo（叫做 favicon），這個小小的 Logo 可以透過以下方式來新增到網頁當中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>隨著網路不斷演進，目前客戶端有多種瀏覽器和設備，所以 favicon 為了演進的需要也提供的多種置入的方式，比如不一定要用 .ico 的格式， .png、.svg 也可以，每個瀏覽器或是設備當中看到的 favicon 最佳大小可能也不相同。由於本文學習和研究的重心主要是在 <code>&lt;meta&gt;</code> ，對這部分的內容可能不夠詳盡，若想深入了解的話，也許可以參考這則在 stackoverflow 上的討論：<a href="https://stackoverflow.com/questions/23849377/html-5-favicon-support">HTML 5 Favicon - Support?</a>。</p><h4 id="標準網址-（Canonical-URL）"><a href="#標準網址-（Canonical-URL）" class="headerlink" title="標準網址 （Canonical URL）"></a>標準網址 （Canonical URL）</h4><p>假設目前有以下的網址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/</span><br><span class="line">http://www.example.com/index.html</span><br><span class="line">http://example.com/</span><br><span class="line">http://example.com/index.html</span><br></pre></td></tr></table></figure><p>但其實這些網址連到的都是同一個網頁，或是在不同網頁上提供相似度極高的內容（例如：行動版和電腦版的網頁，兩者是不同網址但內容幾乎相同）。Google 搜尋引擎便會將這些不同的網址視為相同網頁的重複版本，從中選出一個網址作為「標準」版本進行檢索，然後將其他網址判定為「重複」網址並降低搜尋引擎爬取的頻率。</p><p>如果我們沒有設定一個標準網址的話，Google 搜尋引擎本身就會自己幫我們決定一個標準網址。為了避免這件事情發生，我們其實可以透過以下語法來設定一個自己想要的標準網址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;canonical&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>這也是 <code>&lt;link&gt;</code> 的用途之一。有關標準網址相關資訊，可以參考 Google 搜尋中心的說明：<a href="https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls">整合重複的網址</a>。更多有關 <code>&lt;link&gt;</code>詳細的屬性解說可以參考 MDN 文件：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link">link: The External Resource Link element</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types">Link types</a>。</p><h3 id="lt-base-gt"><a href="#lt-base-gt" class="headerlink" title="&lt;base&gt;"></a><code>&lt;base&gt;</code></h3><p><code>&lt;base&gt;</code> 標籤主要是控制網頁的連結屬性，可以指定網頁的連結根目錄，也可以指定網頁超連結的開啟方式，屬性有 href、target。我們可以直接來看以下兩個範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>這是標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- HTML base href, target 範例設定 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;products&quot;</span>&gt;</span>產品資訊<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about-us&quot;</span>&gt;</span>關於我們<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;faq&quot;</span>&gt;</span>問與答<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>這是標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/products&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>產品資訊<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/about-us&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>關於我們<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/faq&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>問與答<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上兩個程式碼達成的效果其實是相同的。上面的程式碼有使用 <code>&lt;base&gt;</code>，直接指定整個網頁的連結開頭，還有這個網頁按下超連結時會使用開啟新分頁的方式，所以就不需要針對每一個 <code>&lt;a&gt;</code> 進行處理；下面的程式碼沒有使用 <code>&lt;base&gt;</code>，所以便會針對每一個 <code>&lt;a&gt;</code> 進行處理。</p><p>另外需要注意的是：只要有設定 <code>&lt;base&gt;</code> 的 <code>href</code>，任何網頁中的連結都會被它給覆蓋過去。更多有關 <code>&lt;base&gt;</code> 的用法可以參考這些資源：<a href="https://seanacnet.com/html/base-html/">base html 標籤是什麼? html tag 設定網頁連結 - SEAN 工作版</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">base: The Document Base URL element - MDN</a>。</p><h3 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><p>可以使用 <code>&lt;script&gt;</code> 這個標籤來引入 JavaScript，執行一些這個 <code>HTML</code> 網頁所需要的程式碼，比如 CDN 、Gooogle Analytics、網頁互動邏輯等等，可以使用以下兩種不同的方式引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：直接將 JavaSript 寫在裡面</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"> <span class="comment">&lt;!-- 要執行的 JavaScript --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 方法二：插入一個 JavaScript 檔</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;[folder_name]/[file_name].js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外在使用 <code>&lt;script&gt;</code> 這個標籤時，可以特別注意某些屬性是怎麼使用的，比如說： <code>defer</code> 和 <code>async</code> 的差別、<code>type=&quot;module&quot;</code> 怎麼用等等。更多詳細的屬性解說可以參考 MDN 文件：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">script: The Script element</a>。</p><h3 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h3><p>除了上述使用到的標籤之外，可能也還有很多 metadata 需要寫進 <code>HTML</code> 檔裡，比如這個網頁的編碼方式、這個網頁的作者、這個網頁的描述等等，這些都可以使用 <code>&lt;meta&gt;</code> 這個標籤來實現。簡單來說，除了前面提到的標籤以及它們的用途之外，其他的 metadata 都可以寫在 <code>&lt;meta&gt;</code> 這個標籤中，在下一個部分會針對 <code>&lt;meta&gt;</code> 的屬性做更詳細的理解與介紹。</p><h2 id="淺談-lt-meta-gt"><a href="#淺談-lt-meta-gt" class="headerlink" title="淺談 &lt;meta&gt;"></a>淺談 <code>&lt;meta&gt;</code></h2><p>在這個部分會一一介紹幾個 <code>&lt;meta&gt;</code> 當中常用到的 attribute，了解這些 attribute 的用途。</p><h3 id="name、content"><a href="#name、content" class="headerlink" title="name、content"></a>name、content</h3><p>首先第一個登場的 attribute 就是 name 和 content。name 和 content 可以用來描述一個網站的資訊，像是這個網站的作者、這個網站的描述、圖片等等，通常這兩者可以寫在一起，比如下面的範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Simone&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span> <span class="attr">content</span>=<span class="string">&quot;xxx.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這三行程式碼如果直接寫成中文的話，大概呈現的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：Simone</span><br><span class="line">網站描述：This is my page</span><br><span class="line">圖片：xxx.jpg</span><br></pre></td></tr></table></figure><p>同時，這些資訊也可以讓搜尋引擎查詢，讓搜尋引擎知道這個網頁到底是什麼樣的網頁。</p><p>另外有一個可能需要特別注意的地方：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html, css, javascript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以往 name 有一個 keywords 的寫法，表示這個網站會用到的關鍵字，提供搜尋引擎尋找，但目前 Google 有說搜尋引擎目前不會查詢 keywords 了。所以如果有需要的話，可以改成寫在 meta description 當中。</p><h3 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h3><p>charset 這個 attribute 是用來設定該網頁會用何種方式來進行編碼，比如以下的範例使用 utf-8 方式還進行編碼，也是目前網頁常用到的編碼方式。HTML5 預設的編碼方式也是 utf-8。（編碼的方式有非常多種，也許之後也可以寫筆記來研究研究）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><p>http-equiv 會告訴瀏覽器該如何處理這份文件。</p><p>在對伺服器發出 request 之後，伺服器會回傳 reponse，通常 response 裡面會有 headers。在 <code>meta</code> 當中使用 http-equiv 時，http-equiv 所包含的資訊會類似於 reponse 傳回來的 headers，比如下面兩個範例的意思其實是差不多的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- metadata in HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 伺服器回傳的 headers</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>所以 http-equiv 可以理解成 HTTP response headers equivalent，當中的 equiv 其實就是 equivalent 的意思。</p><p>不過，HTTP response 不是都會有 headers ？為什麼還要在 HTML 文件放入類似的資訊？有可能使用者無法直接獲得 HTTP response headers，所以就需要靠 http-equiv 的資訊了。</p><p>http-equiv 還有另外一個用法是 refresh，可以設定幾秒過後重新整理，或是幾秒過後重新導向某個網址，比如以下的程式碼：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3 秒後重新整理頁面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 5 秒後導向 http://www.example.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5; url=http://www.example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>目前 HTML5 請直接使用 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>， <code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code> 是 HTML4 在用的。</p></blockquote><h3 id="Open-Graph"><a href="#Open-Graph" class="headerlink" title="Open Graph"></a>Open Graph</h3><p>平常在各個社群網站分享網址的時候，除了將一串網址貼到貼文上面之外，是不是還會看有一個區塊，上面會有你分享的網站的標題、敘述、圖片等等，例如下圖：</p><p><img src="https://github.com/SimoneCheng/blog/blob/main/public/images/opengraph.png?raw=true"></p><p>沒錯，上圖中用紅色框起來的部分就是用 Open Graph 辦到的，讓使用者在社群當中分享網站時，可以顯示美美的畫面，且只需要在 <code>&lt;meta&gt;</code> 當中寫下以下程式碼就可以辦到了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Open Graph protocol&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;website&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:url&quot;</span> <span class="attr">content</span>=<span class="string">&quot;https://ogp.me/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image&quot;</span> <span class="attr">content</span>=<span class="string">&quot;https://ogp.me/logo.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;image/png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:width&quot;</span> <span class="attr">content</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:height&quot;</span> <span class="attr">content</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:image:alt&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The Open Graph logo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The Open Graph protocol enables any web page to become a rich object in a social graph.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Open Graph 的官方文件由此去：<a href="https://ogp.me/">https://ogp.me/</a></p></blockquote><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以上就是這次對 metadata、<code>&lt;meta&gt;</code> 的小小研究，透過這次的撰寫，得到的收穫大概是：對 metadata 和 <code>&lt;meta&gt;</code> 有更詳細的了解。同時也可以理解 metadata 當中對 SEO 有幫助的部分，例如：整合標準網址、將 <code>&lt;meta&gt;</code> 的 description 寫的詳細一點等等。</p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://html.com/document/metadata/">What Is Metadata In HTML Documents?: Head Elements Explained</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10237545">What is metadata? - iT邦幫忙</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML">What’s in the head? Metadata in HTML - mozilla</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">meta: The metadata element - mozilla</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想要研究的主題是，網頁前端世界裡的三本柱 ── &lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt;、&lt;code&gt;JavaScript&lt;/code&gt; 之中的 &lt;code&gt;HTML&lt;/code&gt;。雖然 &lt;code&gt;HTML&lt;/code&gt; 並非如同 &lt;code&gt;JavaScript&lt;/code&gt; 有很多程式語言相關的主題與議題能夠探討，但是也是有一些有趣的主題值得研究和探索。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://simonecheng.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>什麼是 Pure Function？在 React 當中的重要性是什麼？</title>
    <link href="https://simonecheng.github.io/react-pure-function/"/>
    <id>https://simonecheng.github.io/react-pure-function/</id>
    <published>2022-01-19T09:36:23.000Z</published>
    <updated>2022-05-15T10:41:50.940Z</updated>
    
    <content type="html"><![CDATA[<p>在 functional programming 當中，有一個重要的概念稱為 pure function，而這個概念在 React 的官方文件當中被提起，那麼 pure function 在 React 當中到底扮演了什麼樣的角色呢？這是本文試圖理解並回答的問題。</p><span id="more"></span><p>目前的文章架構如下：</p><ul><li>什麼是 pure function？  </li><li>為什麼我們需要 pure function？</li><li>為什麼 pure function 在 React 裡面是重要的？</li></ul><p>在閱讀本文之前，你可能要有的先備知識：</p><ul><li>了解 React hooks 如何運作</li><li>了解 React functional components 裡面的 life cycle</li><li>了解一點點 Redux</li><li>最重要的是：了解 JavaScript</li></ul><h2 id="什麼是-pure-function？"><a href="#什麼是-pure-function？" class="headerlink" title="什麼是 pure function？"></a>什麼是 pure function？</h2><blockquote><p>A pure function is a function which:</p><ul><li>The function always returns the same result if the same arguments are passed in. It does not depend on any state, or data, change during a program’s execution. It must only depend on its input arguments.</li><li>The function does not produce any observable side effects such as network requests, input and output devices, or data mutation.</li></ul></blockquote><p>簡單來說，一個 function 只要符合以下兩個條件：</p><ol><li>相同的 input，永遠都輸出相同的 output。</li><li>沒有產生 side effect。跟其他function不會互相干擾，不會修改&#x2F;引用&#x2F;存取或是依賴到到外部變數，但是當作參數傳入是可以的。</li></ol><p>我們就可以把這個 function 稱為 pure function。但要怎麼樣才能符合這兩個條件餒？接下來可以來細看這兩個條件的意涵。</p><h3 id="條件一：相同的-input，永遠都輸出相同的-output"><a href="#條件一：相同的-input，永遠都輸出相同的-output" class="headerlink" title="條件一：相同的 input，永遠都輸出相同的 output"></a>條件一：相同的 input，永遠都輸出相同的 output</h3><h4 id="❌-不符合條件一的例子"><a href="#❌-不符合條件一的例子" class="headerlink" title="❌ 不符合條件一的例子"></a>❌ 不符合條件一的例子</h4><p>以下兩個 function 每次的 output 都不一樣，所以不符合條件一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">now</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br></pre></td></tr></table></figure><h4 id="✔️-符合條件一的例子"><a href="#✔️-符合條件一的例子" class="headerlink" title="✔️ 符合條件一的例子"></a>✔️ 符合條件一的例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b都是整數</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; input 是 1, 2，永遠都 return 3</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// =&gt; input 是 3, 5，永遠都 return 8</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// =&gt; input 是 4, 6，永遠都 return 10</span></span><br></pre></td></tr></table></figure><h3 id="條件二：沒有產生-side-effect"><a href="#條件二：沒有產生-side-effect" class="headerlink" title="條件二：沒有產生 side effect"></a>條件二：沒有產生 side effect</h3><h4 id="什麼是-side-effect？"><a href="#什麼是-side-effect？" class="headerlink" title="什麼是 side effect？"></a>什麼是 side effect？</h4><blockquote><p>An observable side effect is any interaction with the outside world from within a function. That could be anything from changing a variable that exists outside the function, to calling another method from within a function.</p><p>Note: If a pure function calls a pure function this isn’t a side effect and the calling function is still pure.</p></blockquote><p>簡單來說，side effect 指的就是在執行某個 function 時，該 function 的作用會影響到外面（比如全域環境或是其他 function 裡的東西），那麼「會影響到該 function 外面」這個行為，就叫做 side effect。</p><p>雖然 side effect 聽起來很像是負面的名詞，但不表示 side effect 就是不好的，在程式當中，side effect 單純就只是描述在寫 function 時有可能會出現的情況或是現象而已。</p><h4 id="side-effect-有哪些？"><a href="#side-effect-有哪些？" class="headerlink" title="side effect 有哪些？"></a>side effect 有哪些？</h4><p>以下介紹一些常見的 side effect，但不限於此：</p><ol><li>Making a HTTP request</li><li>Mutating data</li><li>Printing to a screen or console</li><li>DOM Query&#x2F;Manipulation</li><li>Math.random()</li><li>Getting the current time</li></ol><p>接下來直接以程式碼來舉例有 side effect 的 function 長什麼樣子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">impureAssoc</span>(<span class="params">key, value, object</span>) &#123;</span><br><span class="line">  object[key] = value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bobo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">impureAssoc</span>(<span class="string">&#x27;shoeSize&#x27;</span>, <span class="number">400</span>, person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br></pre></td></tr></table></figure><p>在上述的程式碼當中，當把 <code>person</code> 傳入 <code>impureAssoc</code> 這個 fucntion 裡面之後，<code>person</code> 從 <code>&#123; name: &#39;Bobo&#39; &#125;</code> 變成 <code>&#123; name: &#39;Bobo&#39;, shoeSize: 400 &#125;</code>。也就是說，透過 <code>impureAssoc</code> 這個 function，改變了全域變數 <code>person</code>，這也意味著這個 function 有 side effect。</p><p>我們把程式碼稍微改一下，在原本的 function 中先將傳入的 object 複製出一份一模一樣的，然後針對複製出來的那份進行修改，就可以消除這個 function 的 side effect：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pureAssoc</span> = (<span class="params">key, value, object</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newObject = &#123; ...object &#125;;</span><br><span class="line">  newObject[key] = value;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bobo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">pureAssoc</span>(<span class="string">&#x27;shoeSize&#x27;</span>, <span class="number">400</span>, person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Bobo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; name: &#x27;Bobo&#x27;, shoeSize: 400 &#125;</span></span><br></pre></td></tr></table></figure><p>如此一來，我們在沒有改動到原本的 <code>person</code> 的情況下，得到我們想要的 <code>result</code>。於是這個原本不 pure 的 function，也變 pure 了。</p><div class="warning">⚠️ <b>淺拷貝 v.s.深拷貝</b><br>你的複製真的是成功的複製嗎？有沒有可能你其實沒有複製到，所以還是會改動到原本的 data？  </div><h2 id="為什麼我們需要-pure-function？"><a href="#為什麼我們需要-pure-function？" class="headerlink" title="為什麼我們需要 pure function？"></a>為什麼我們需要 pure function？</h2><p>大概了解 pure function 的定義和什麼是 pure function 之後，就要來問：所以為什麼需要 pure function？它是用來幹嘛的？</p><p><strong>1.immediately testable, maintain and refactor easier</strong></p><p>「相同的 input，永遠都輸出相同的 output。」這個 pure function 的特性使它能夠非常容易地被拿來測試。</p><p>當你寫的程式越來越龐大，程式碼的閱讀性與語法簡潔、易於測試、維護與除錯、易於規模化等等，都會變成要考量的重點，這時 pure function 的好處就會非常明顯──好讀、好維護、data的改動可以被追蹤、比較不會出現一些預期之外的錯誤（side effect）。</p><p><strong>2.是 functional programming 很重要的 basic concept。</strong></p><h2 id="為什麼-pure-function-在-React-裡面是重要的？"><a href="#為什麼-pure-function-在-React-裡面是重要的？" class="headerlink" title="為什麼 pure function 在 React 裡面是重要的？"></a>為什麼 pure function 在 React 裡面是重要的？</h2><p>在 React 的官方文件 <a href="https://reactjs.org/docs/components-and-props.html">Components and Props</a> 中，特別提到了一句話：</p><blockquote><p>All React components must act like <strong>pure functions</strong> with respect to their props.</p></blockquote><p><img src="https://i.imgur.com/FtP80vu.png"></p><p>pure function 在 React 當中之所以重要，是因為：</p><ol><li>functional component：關係到 <code>useState()</code> 會不會將傳入的 state 視為不同的資料，然後重新 render。範例：<a href="https://codesandbox.io/s/case-1-wd1dh?file=/src/App.js">https://codesandbox.io/s/case-1-wd1dh?file=/src/App.js</a></li><li>確保不管在任何情況之下，傳入相同的 input，都會渲染出相同的畫面給使用者看（output）。</li><li>redux：和 <code>useState()</code> 也是同樣的道理，所以 reducers 也規定必須是 pure function。</li><li>還沒有 hooks 時，在 functional component 裡面，讓 props 只能是唯讀的，使資料在修改的時候比較好追蹤和管理。</li><li>A React component should be pure, this means the result of its render method should depend solely on the props and the state, and for the same properties and state render should give the same result. If render is not pure, it means it can return different results for the same input, so React cannot tell which parts of the DOM need to be updated based on the changes to the component. This is critical as the performance of React depends of this.</li></ol><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><a href="https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/">What Is a Pure Function in JavaScript? - FreeCodeCamp</a></li><li><a href="https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c">JavaScript: What Are Pure Functions And Why Use Them? - Medium</a></li><li><a href="https://dev.to/keevcodes/pure-functions-in-react-2o7n">Pure Functions in React - DEV</a></li><li><a href="https://blog.logrocket.com/react-pure-components-functional/">Pure functional components in React - LogRocket</a></li><li><a href="https://betterprogramming.pub/react-class-vs-functional-components-2327c7324bdd">React Class vs. Functional Components - Medium</a></li><li><a href="https://stackoverflow.com/questions/41985547/why-reactjs-components-must-act-like-pure-functions">Why ReactJS components must act like pure functions?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 functional programming 當中，有一個重要的概念稱為 pure function，而這個概念在 React 的官方文件當中被提起，那麼 pure function 在 React 當中到底扮演了什麼樣的角色呢？這是本文試圖理解並回答的問題。&lt;/p&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://simonecheng.github.io/tags/React/"/>
    
    <category term="funcitonal programming" scheme="https://simonecheng.github.io/tags/funcitonal-programming/"/>
    
  </entry>
  
</feed>
